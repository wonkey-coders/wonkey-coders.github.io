{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wonkey! # Wonkey is an open-source cross-platform programming language. Wonkey is a fork of the Monkey2 programming language, developed by Mark Sibly, creator of the \u2018Blitz\u2019 range of languages (BlitzBasic, Blitz2D, Blitz3D, BlitzPlus, BlitzMax). Wonkey is a community project. Wonkey offers some very powerful new features including: Function overloading Functions with the same name can have different parameter types. Function Add ( a : Int , b : Int ) Return a + b End Function Add ( a : Float , b : Float ) Return a + b End 'First class' functions Functions (and methods) can be stored in variables and passed to/from other functions. Function Test1 () Print \"Test1!\" End Function Test2 () Print \"Test2!\" End Function Tester ( test : Void () ) test () End Function Main () Tester ( Test1 ) Tester ( Test2 ) End Lambda functions Lambda functions allow you to create closures: Function Test ( func : Void () ) func () End Function Main () For Local i : = 0 Until 10 Test ( Lambda () Print i End ) Next End Templates / Generics Classes, interfaces, structs, methods and functions can have \u2018type\u2019 parameters: Struct Rect < T > Field x : T Field y : T Field width : T Field height : T End Function Main () Local r : = New Rect < Float > End Structs Structs are similar to classes in that they encapsulate member data, but differ in that they are passed around \u2018by value\u2019 instead of \u2018by reference\u2019. This allows structs to be efficiently created on the stack without any garbage collection overhead. Struct S Field data : Int = 10 End Function Test ( s : S ) s . data = 100 End Function Main () Local s : = New S ' Create a new S on the stack (very fast!) Test ( s ) ' Test gets a copy of 's'. Print s . data ' Print '10' End Fibers Fibers provide support for \u2018cooperative\u2019 multithreading: Function Server ( host : String , service : String ) Local server : = Socket . Listen ( host , service ) Repeat Local client : = server . Accept () New Fiber ( Lambda () Local data : = client . Receive (...) End ) Forever End Operator overloading Operator overloading allows you to override the meaning of the built-in language operators, making for more expressive code: Struct Vec2 Field x : Float Field y : Float Method New ( x : float , y : Float ) Self . x = x Self . y = y End Operator + : Vec2 ( v : Vec2 ) Return New Vec2 ( x + v . x , y + v . y ) End Operator To : String () Return \"Vec2(\" + x + \",\" + y + \")\" End End Function Main () Local v0 : = New Vec2 ( 10 , 20 ) Local v1 : = New Vec2 ( 30 , 40 ) Print v0 + v1 End Optional reflection features Wonkey includes an optional reflection system that allows you to inspect and modify variables and values at runtime: # Import \"<reflection>\" Class C Method Update ( msg : String ) Print \"C.Update : msg=\" + msg End End Function Main () Local c : = New C Local type : = Typeof ( c ) Print type Local decl : = type . GetDecl ( \"Update\" ) decl . Invoke ( c , \"Hello World!\" ) End Class extensions Class extensions allow you to add extra methods and functions to existing classes. Fully garbage collected Wonkey provides a \u2018mostly\u2019 incremental garbage collector that efficiently collects garbage as it runs without any of those annoying \u2018sweep\u2019 spikes found in typical garbage collectors.","title":"Start"},{"location":"#welcome_to_wonkey","text":"Wonkey is an open-source cross-platform programming language. Wonkey is a fork of the Monkey2 programming language, developed by Mark Sibly, creator of the \u2018Blitz\u2019 range of languages (BlitzBasic, Blitz2D, Blitz3D, BlitzPlus, BlitzMax). Wonkey is a community project. Wonkey offers some very powerful new features including: Function overloading Functions with the same name can have different parameter types. Function Add ( a : Int , b : Int ) Return a + b End Function Add ( a : Float , b : Float ) Return a + b End 'First class' functions Functions (and methods) can be stored in variables and passed to/from other functions. Function Test1 () Print \"Test1!\" End Function Test2 () Print \"Test2!\" End Function Tester ( test : Void () ) test () End Function Main () Tester ( Test1 ) Tester ( Test2 ) End Lambda functions Lambda functions allow you to create closures: Function Test ( func : Void () ) func () End Function Main () For Local i : = 0 Until 10 Test ( Lambda () Print i End ) Next End Templates / Generics Classes, interfaces, structs, methods and functions can have \u2018type\u2019 parameters: Struct Rect < T > Field x : T Field y : T Field width : T Field height : T End Function Main () Local r : = New Rect < Float > End Structs Structs are similar to classes in that they encapsulate member data, but differ in that they are passed around \u2018by value\u2019 instead of \u2018by reference\u2019. This allows structs to be efficiently created on the stack without any garbage collection overhead. Struct S Field data : Int = 10 End Function Test ( s : S ) s . data = 100 End Function Main () Local s : = New S ' Create a new S on the stack (very fast!) Test ( s ) ' Test gets a copy of 's'. Print s . data ' Print '10' End Fibers Fibers provide support for \u2018cooperative\u2019 multithreading: Function Server ( host : String , service : String ) Local server : = Socket . Listen ( host , service ) Repeat Local client : = server . Accept () New Fiber ( Lambda () Local data : = client . Receive (...) End ) Forever End Operator overloading Operator overloading allows you to override the meaning of the built-in language operators, making for more expressive code: Struct Vec2 Field x : Float Field y : Float Method New ( x : float , y : Float ) Self . x = x Self . y = y End Operator + : Vec2 ( v : Vec2 ) Return New Vec2 ( x + v . x , y + v . y ) End Operator To : String () Return \"Vec2(\" + x + \",\" + y + \")\" End End Function Main () Local v0 : = New Vec2 ( 10 , 20 ) Local v1 : = New Vec2 ( 30 , 40 ) Print v0 + v1 End Optional reflection features Wonkey includes an optional reflection system that allows you to inspect and modify variables and values at runtime: # Import \"<reflection>\" Class C Method Update ( msg : String ) Print \"C.Update : msg=\" + msg End End Function Main () Local c : = New C Local type : = Typeof ( c ) Print type Local decl : = type . GetDecl ( \"Update\" ) decl . Invoke ( c , \"Hello World!\" ) End Class extensions Class extensions allow you to add extra methods and functions to existing classes. Fully garbage collected Wonkey provides a \u2018mostly\u2019 incremental garbage collector that efficiently collects garbage as it runs without any of those annoying \u2018sweep\u2019 spikes found in typical garbage collectors.","title":"Welcome to Wonkey!"},{"location":"about_docs/","text":"Welcome to MkDocs # For full documentation visit mkdocs.org . Commands # mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout # mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Note Simple note Please note: To use notes you must add 'admonition' to the markdown extensions in mkdocs.yml: markdown_extensions: - admonition Code Block Line2 Simple note without title. Seealso seealso note Abstract abstract note Summary summary note Tldr tldr note Info info note Todo todo note Tip tip note Hint hint note Important important note Success success note Check check note Done done note Question question note Help help note Faq faq note Warning warning note Caution caution note Attention attention note Failure failure note Fail fail note Missing missing note Danger danger note Error error note Bug bug note Example example note Snippet snippet note Quote quote note Cite cite note Code: Fenced code blocks are like Standard Markdown\u2019s regular code blocks, except that they\u2019re not indented and instead rely on start and end fence lines to delimit the code block. Python Code: def fn (): pass Wonkey Code: Function Main : Void () Print \"Hello World!\" End Inline code : Function Main () Lorem ipsum dolor sit amet, consectetur adipiscing elit Nulla lobortis egestas semper Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque Nulla vel eros venenatis, imperdiet enim id, faucibus nisi Strikethrough text","title":"Welcome to MkDocs"},{"location":"about_docs/#welcome_to_mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"about_docs/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"about_docs/#project_layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Note Simple note Please note: To use notes you must add 'admonition' to the markdown extensions in mkdocs.yml: markdown_extensions: - admonition Code Block Line2 Simple note without title. Seealso seealso note Abstract abstract note Summary summary note Tldr tldr note Info info note Todo todo note Tip tip note Hint hint note Important important note Success success note Check check note Done done note Question question note Help help note Faq faq note Warning warning note Caution caution note Attention attention note Failure failure note Fail fail note Missing missing note Danger danger note Error error note Bug bug note Example example note Snippet snippet note Quote quote note Cite cite note Code: Fenced code blocks are like Standard Markdown\u2019s regular code blocks, except that they\u2019re not indented and instead rely on start and end fence lines to delimit the code block. Python Code: def fn (): pass Wonkey Code: Function Main : Void () Print \"Hello World!\" End Inline code : Function Main () Lorem ipsum dolor sit amet, consectetur adipiscing elit Nulla lobortis egestas semper Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque Nulla vel eros venenatis, imperdiet enim id, faucibus nisi Strikethrough text","title":"Project layout"},{"location":"community/","text":"Community Demos # DruggedBunny #","title":"Community Examples"},{"location":"community/#community_demos","text":"","title":"Community Demos"},{"location":"community/#druggedbunny","text":"","title":"DruggedBunny"},{"location":"examples/","text":"Wonkey Examples # Click screenshots to run the examples in browser. Pool/Billard # Commanche # Toy-Plane #","title":"Wonkey Examples"},{"location":"examples/#wonkey_examples","text":"Click screenshots to run the examples in browser.","title":"Wonkey Examples"},{"location":"examples/#poolbillard","text":"","title":"Pool/Billard"},{"location":"examples/#commanche","text":"","title":"Commanche"},{"location":"examples/#toy-plane","text":"","title":"Toy-Plane"},{"location":"docs/guide/","text":"Wonkey User Guide #","title":"Overview"},{"location":"docs/guide/#wonkey_user_guide","text":"","title":"Wonkey User Guide"},{"location":"docs/guide/wake/","text":"The command-line compiler # wake is the command-line compiler for Wonkey. Please note The actual executable name of the command-line compiler is different and depends on the operating system! The compiler binary # The Wonkey compiler wake is located in the bin/ directory of your Wonkey installation. See the following table for the actual executable name on each host platform: Platform Compiler binary Windows /bin/windows/wake.exe Linux /bin/linux/wake macOS /bin/macos/wake Raspberry Pi /bin/raspbian/wake Hint If you add the Wonkey/bin/%OS% directory to your PATH environment variable, you are able to use the Wonkey compiler directly from every directory on the command-line or in a terminal. Compiler usage # The command-line options for wake are: wake command options input Compiler commands # Command Description app Build an application. input should be a *.wx file. mods Build module(s). input should be a space separated list of module names, or nothing to make all modules. docs Build the documentation for a set of modules. input should be a space separated list of module names, or nothing to make all modules. Compiler options # Option Description -quiet Emit less info when building. -verbose= Emit more info when building, one of: none, 0 to 3. (Defaults: 1 or -1 if quiet). -clean Force clean rebuild. -time Output build time information. -parse Parse only. Checks for parsing errors. -semant Parse and semant. Checks for parsing and semantic errors. -translate Parse, semant and translate. -build Parse, semant, translate and build. -run Runs the application after successful build. -target= target Set target to one of the following values: desktop (default: alias for current host), windows , macos , linux , raspbian , android , ios , emscripten , wasm -config= config Set config to: debug , release , or all . (Defaults: all for modules else debug ) -apptype= apptype Set apptype to: gui (default) or console -product= path path is the build output path Examples # Compile a desktop gui app in debug mode (default) and run it: wake app main.wx Compile a console application in release mode for the host operating system and run it: wake app -config=release -apptype=console myfile.wx Compile a game for the 'iOS' target: wake app -config=release -target=ios mygame.wx Build the complete docs: wake docs Force clean rebuild of all modules for the 'Android' target in release and debug mode: wake mods -clean -target=android -config=debug wake mods -clean -target=android -config=release Compile your own module 'mymodule'. The module/library must be located in the 'modules' directory. wake mods -config=debug mymodule wake mods -config=release mymodule","title":"The 'wake' compiler"},{"location":"docs/guide/wake/#the_command-line_compiler","text":"wake is the command-line compiler for Wonkey. Please note The actual executable name of the command-line compiler is different and depends on the operating system!","title":"The command-line compiler"},{"location":"docs/guide/wake/#the_compiler_binary","text":"The Wonkey compiler wake is located in the bin/ directory of your Wonkey installation. See the following table for the actual executable name on each host platform: Platform Compiler binary Windows /bin/windows/wake.exe Linux /bin/linux/wake macOS /bin/macos/wake Raspberry Pi /bin/raspbian/wake Hint If you add the Wonkey/bin/%OS% directory to your PATH environment variable, you are able to use the Wonkey compiler directly from every directory on the command-line or in a terminal.","title":"The compiler binary"},{"location":"docs/guide/wake/#compiler_usage","text":"The command-line options for wake are: wake command options input","title":"Compiler usage"},{"location":"docs/guide/wake/#compiler_commands","text":"Command Description app Build an application. input should be a *.wx file. mods Build module(s). input should be a space separated list of module names, or nothing to make all modules. docs Build the documentation for a set of modules. input should be a space separated list of module names, or nothing to make all modules.","title":"Compiler commands"},{"location":"docs/guide/wake/#compiler_options","text":"Option Description -quiet Emit less info when building. -verbose= Emit more info when building, one of: none, 0 to 3. (Defaults: 1 or -1 if quiet). -clean Force clean rebuild. -time Output build time information. -parse Parse only. Checks for parsing errors. -semant Parse and semant. Checks for parsing and semantic errors. -translate Parse, semant and translate. -build Parse, semant, translate and build. -run Runs the application after successful build. -target= target Set target to one of the following values: desktop (default: alias for current host), windows , macos , linux , raspbian , android , ios , emscripten , wasm -config= config Set config to: debug , release , or all . (Defaults: all for modules else debug ) -apptype= apptype Set apptype to: gui (default) or console -product= path path is the build output path","title":"Compiler options"},{"location":"docs/guide/wake/#examples","text":"Compile a desktop gui app in debug mode (default) and run it: wake app main.wx Compile a console application in release mode for the host operating system and run it: wake app -config=release -apptype=console myfile.wx Compile a game for the 'iOS' target: wake app -config=release -target=ios mygame.wx Build the complete docs: wake docs Force clean rebuild of all modules for the 'Android' target in release and debug mode: wake mods -clean -target=android -config=debug wake mods -clean -target=android -config=release Compile your own module 'mymodule'. The module/library must be located in the 'modules' directory. wake mods -config=debug mymodule wake mods -config=release mymodule","title":"Examples"},{"location":"docs/guide/sdks/","text":"Wonkey Target SDKs # Wonkey requires external tools and Software Development Kits (SDKs) for some targets. In the following sections you will find the requirements for each platform and target: Android Emscripten iOS Linux macOS Raspberry Pi Windows","title":"Overview"},{"location":"docs/guide/sdks/#wonkey_target_sdks","text":"Wonkey requires external tools and Software Development Kits (SDKs) for some targets. In the following sections you will find the requirements for each platform and target: Android Emscripten iOS Linux macOS Raspberry Pi Windows","title":"Wonkey Target SDKs"},{"location":"docs/guide/sdks/android/","text":"Android # The 'Android' Target # Wonkey uses the android NDK (native development kit) to build android apps. Setting up for Android development # Install Android Studio and make sure it works, ie: you can build and run one of the simple template projects on a device or emulator. Android Studio is available here: Android Studio . Install the 'NDK' (native development kit) using Android Studio via 'SDK Manager->SDK Tools'. Install the Android 7.0 (Nougat) SDK Platform (API Level 24) using Android Studio via 'SDK Manager'. Edit your Wonkey bin/windows/env_windows.txt file and change the ndk-bundle 'PATH' setting so it points to the NDK. Or, you can just add the ndk-bundle directory to your system PATH. Please note: Use the file bin/macos/env_macos.txt on macOS and bin/linux/env_linux.txt on Linux. Fire up the Wide IDE and select 'Build -> Update/Rebuild Modules -> Android'. Alternatively you can (re-)build the android modules on the command-line: wake mods -clean -target=android -config=debug wake mods -clean -target=android -config=release Building an Android app # Build your app in Wide using 'Build -> Build Only' with 'Build Target -> Android' selected. Open the generated Android Studio project (at myapp.products/Android) in Android Studio. Attention I recommend disabling the following Android Studio setting for Wonkey development: File -> Settings -> Build, Execution, Deployment -> Instant Run -> Enable Instant Run With this enabled, Android Studio doesn't seem to notice when external project files change.","title":"Android"},{"location":"docs/guide/sdks/android/#android","text":"","title":"Android"},{"location":"docs/guide/sdks/android/#the_android_target","text":"Wonkey uses the android NDK (native development kit) to build android apps.","title":"The 'Android' Target"},{"location":"docs/guide/sdks/android/#setting_up_for_android_development","text":"Install Android Studio and make sure it works, ie: you can build and run one of the simple template projects on a device or emulator. Android Studio is available here: Android Studio . Install the 'NDK' (native development kit) using Android Studio via 'SDK Manager->SDK Tools'. Install the Android 7.0 (Nougat) SDK Platform (API Level 24) using Android Studio via 'SDK Manager'. Edit your Wonkey bin/windows/env_windows.txt file and change the ndk-bundle 'PATH' setting so it points to the NDK. Or, you can just add the ndk-bundle directory to your system PATH. Please note: Use the file bin/macos/env_macos.txt on macOS and bin/linux/env_linux.txt on Linux. Fire up the Wide IDE and select 'Build -> Update/Rebuild Modules -> Android'. Alternatively you can (re-)build the android modules on the command-line: wake mods -clean -target=android -config=debug wake mods -clean -target=android -config=release","title":"Setting up for Android development"},{"location":"docs/guide/sdks/android/#building_an_android_app","text":"Build your app in Wide using 'Build -> Build Only' with 'Build Target -> Android' selected. Open the generated Android Studio project (at myapp.products/Android) in Android Studio. Attention I recommend disabling the following Android Studio setting for Wonkey development: File -> Settings -> Build, Execution, Deployment -> Instant Run -> Enable Instant Run With this enabled, Android Studio doesn't seem to notice when external project files change.","title":"Building an Android app"},{"location":"docs/guide/sdks/emscripten/","text":"Emscripten # The 'emscripten' Target # Wonkey uses the emscripten sdk compilers and tools to build wasm and asm.js apps.","title":"Emscripten"},{"location":"docs/guide/sdks/emscripten/#emscripten","text":"","title":"Emscripten"},{"location":"docs/guide/sdks/emscripten/#the_emscripten_target","text":"Wonkey uses the emscripten sdk compilers and tools to build wasm and asm.js apps.","title":"The 'emscripten' Target"},{"location":"docs/guide/sdks/ios/","text":"iOS # The 'iOS' Target # Wonkey requires Apple Xcode to build apps for iOS. Building an iOS app # Build your app inside Wide using 'Build -> Build Only' with 'Build Target -> iOS' selected. Open the generated Xcode project (at myapp.products/iOS/) and run it.","title":"iOS"},{"location":"docs/guide/sdks/ios/#ios","text":"","title":"iOS"},{"location":"docs/guide/sdks/ios/#the_ios_target","text":"Wonkey requires Apple Xcode to build apps for iOS.","title":"The 'iOS' Target"},{"location":"docs/guide/sdks/ios/#building_an_ios_app","text":"Build your app inside Wide using 'Build -> Build Only' with 'Build Target -> iOS' selected. Open the generated Xcode project (at myapp.products/iOS/) and run it.","title":"Building an iOS app"},{"location":"docs/guide/sdks/linux/","text":"Linux # The 'Linux' Target # Wonkey uses the gcc command line tools to build desktop apps for Linux. You will also need to install all the developer libraries required by the compiler and modules. This will differ depending on the precise version of Linux you have, but to get you started: sudo apt-get update && sudo apt-get upgrade sudo apt-get install g++-multilib libopenal-dev libpulse-dev libsdl2-dev","title":"Linux"},{"location":"docs/guide/sdks/linux/#linux","text":"","title":"Linux"},{"location":"docs/guide/sdks/linux/#the_linux_target","text":"Wonkey uses the gcc command line tools to build desktop apps for Linux. You will also need to install all the developer libraries required by the compiler and modules. This will differ depending on the precise version of Linux you have, but to get you started: sudo apt-get update && sudo apt-get upgrade sudo apt-get install g++-multilib libopenal-dev libpulse-dev libsdl2-dev","title":"The 'Linux' Target"},{"location":"docs/guide/sdks/mac/","text":"macOS # The 'macOS' Target # Wonkey uses the command line tools included with Apple Xcode to build desktop apps for macOS.","title":"macOS"},{"location":"docs/guide/sdks/mac/#macos","text":"","title":"macOS"},{"location":"docs/guide/sdks/mac/#the_macos_target","text":"Wonkey uses the command line tools included with Apple Xcode to build desktop apps for macOS.","title":"The 'macOS' Target"},{"location":"docs/guide/sdks/raspberry/","text":"Raspberry Pi # The 'Raspberry Pi' Target # See Linux","title":"Raspberry Pi"},{"location":"docs/guide/sdks/raspberry/#raspberry_pi","text":"","title":"Raspberry Pi"},{"location":"docs/guide/sdks/raspberry/#the_raspberry_pi_target","text":"See Linux","title":"The 'Raspberry Pi' Target"},{"location":"docs/guide/sdks/windows/","text":"Windows # The 'Windows' Target # Wonkey can use either the mingw compiler or Microsoft Build Tools 2019 to build desktop apps. To use mingw, you can use the mingw build tools at github.com/wonkey-coders/wonkey . Simply download the mingw build tools package, run it (it's a self extracting exe), and select your 'Wonkey/devtools' dir for installation. To use MS Build Tools 2019 instead of mingw, you will need to install MS Build Tools 2019 and change the following line in bin/windows/env_windows.txt: #WX_USE_MSVC=1 WX_MSVC_DIR=${ProgramFiles(x86)}\\Microsoft Visual Studio\\2019\\BuildTools\\VC WX_MSVC_TOOLS_DIR=${WX_MSVC_DIR}\\Tools\\MSVC\\14.28.29333 WX_WINDOWS_KITS_DIR=${ProgramFiles(x86)}\\Windows Kits\\10 WX_WINDOWS_KIT=10.0.18362.0 You will need to rebuild all desktop modules after doing this. Downloads for MS Build Tools 2019 can be found here: MS Build Tools 2019 .","title":"Windows"},{"location":"docs/guide/sdks/windows/#windows","text":"","title":"Windows"},{"location":"docs/guide/sdks/windows/#the_windows_target","text":"Wonkey can use either the mingw compiler or Microsoft Build Tools 2019 to build desktop apps. To use mingw, you can use the mingw build tools at github.com/wonkey-coders/wonkey . Simply download the mingw build tools package, run it (it's a self extracting exe), and select your 'Wonkey/devtools' dir for installation. To use MS Build Tools 2019 instead of mingw, you will need to install MS Build Tools 2019 and change the following line in bin/windows/env_windows.txt: #WX_USE_MSVC=1 WX_MSVC_DIR=${ProgramFiles(x86)}\\Microsoft Visual Studio\\2019\\BuildTools\\VC WX_MSVC_TOOLS_DIR=${WX_MSVC_DIR}\\Tools\\MSVC\\14.28.29333 WX_WINDOWS_KITS_DIR=${ProgramFiles(x86)}\\Windows Kits\\10 WX_WINDOWS_KIT=10.0.18362.0 You will need to rebuild all desktop modules after doing this. Downloads for MS Build Tools 2019 can be found here: MS Build Tools 2019 .","title":"The 'Windows' Target"},{"location":"docs/lang/","text":"Wonkey Language Reference # This section of the Wonkey reference describes the Wonkey language.","title":"Overview"},{"location":"docs/lang/#wonkey_language_reference","text":"This section of the Wonkey reference describes the Wonkey language.","title":"Wonkey Language Reference"},{"location":"docs/lang/alias/","text":"Alias # Introduction # An Alias allows you to create a synonym for a previously declared type. Alias Identifier : Type You can use your newly declared Alias instead of the original type anywhere in your code. For example: Alias FantasticNumber : Int Alias FantasticString : String Local myInt : FantasticNumber = 123 Local myString : FantasticString = \"abc\"","title":"Aliases"},{"location":"docs/lang/alias/#alias","text":"","title":"Alias"},{"location":"docs/lang/alias/#introduction","text":"An Alias allows you to create a synonym for a previously declared type. Alias Identifier : Type You can use your newly declared Alias instead of the original type anywhere in your code. For example: Alias FantasticNumber : Int Alias FantasticString : String Local myInt : FantasticNumber = 123 Local myString : FantasticString = \"abc\"","title":"Introduction"},{"location":"docs/lang/array/","text":"Array # Introduction # An array is a linear sequence of values that can be addressed using one or more integer indices. Arrays are '0 based' in Wonkey, meaning the first element in an array is at index 0, the second is at index 1, the third is at index 2 and so on. Each array has an associated element type. That is, the type of the values actually stored in the array. An array's element type is a purely static property. It is only known at compile time so arrays cannot be 'cast' to different array types at runtime. Array variables are declared using the syntax: ElementType [ [, ...] ] An array can be multidimensional, in which case the '[]' will contain 1 or more commas. Here are some example of declaring array variables: Local ints : Int [] ' One dimensional Int array Local arr [,] ' Two dimension Int array Local funcs : Int ()[] ' One dimensional array of functions of type Int() Local stacks : Stack < Int >[] ' One dimensional array of stacks of type Int Creating arrays # Declaring an array does not actually create an array. To do that you must use the New operator. New can be used to create either a null intialized or value initialized array. The syntax for creating a null initialized array is: New ElementType [ Sizes ] ...where sizes is a comma separated sequence of dimension sizes. The syntax for creating a value initialized array is: New ElementType [ Sizes ] ( Element0 , Element1 , ...etc ) One dimensional arrays can omit sizes when creating a value initialized array: New ElementType [ ] ( Element0 , Element1 , ...etc ) Here are some examples: ' Creates a ten element integer array Local ints : Int [] = New Int [ 10 ] ' Creates a 5 element float array initialized to 1.0,3,5.1,7,9.2 Local flts : = New Float []( 1.0 , 3 , 5.1 , 7 , 9.2 ) 'Creates a 2x2 element float array initialized to 1,2,3,4 Local flts2 : = New Float [ 2 , 2 ]( 1 , 2 , 3 , 4 ) Iterating through arrays # You can iterate through the elements of an array using Eachin , eg: Local arr : = New Int []( 1 , 3 , 5 , 7 , 9 ) For Local i : = Eachin arr Print i Next Slicing arrays # One dimensional arrays can be sliced using the .Slice() method, eg: Local ints : = New Int []( 1 , 3 , 5 , 7 , 9 ) ints = ints . Slice ( 1 , 4 ) ' ints now contains 3,5,7 Resizing arrays # One dimensional arrays can be resized using the .Resize() method, eg: Local ints : = New Int []( 1 , 2 , 3 ) ints = ints . Resize ( 5 ) ' ints now contains 1,2,3,0,0 Attention Note that .Resize() actually returns a resized copy of the input array! The input array is not modified in any way. Multidimensional arrays cannot currently be sliced or resized.","title":"Arrays"},{"location":"docs/lang/array/#array","text":"","title":"Array"},{"location":"docs/lang/array/#introduction","text":"An array is a linear sequence of values that can be addressed using one or more integer indices. Arrays are '0 based' in Wonkey, meaning the first element in an array is at index 0, the second is at index 1, the third is at index 2 and so on. Each array has an associated element type. That is, the type of the values actually stored in the array. An array's element type is a purely static property. It is only known at compile time so arrays cannot be 'cast' to different array types at runtime. Array variables are declared using the syntax: ElementType [ [, ...] ] An array can be multidimensional, in which case the '[]' will contain 1 or more commas. Here are some example of declaring array variables: Local ints : Int [] ' One dimensional Int array Local arr [,] ' Two dimension Int array Local funcs : Int ()[] ' One dimensional array of functions of type Int() Local stacks : Stack < Int >[] ' One dimensional array of stacks of type Int","title":"Introduction"},{"location":"docs/lang/array/#creating_arrays","text":"Declaring an array does not actually create an array. To do that you must use the New operator. New can be used to create either a null intialized or value initialized array. The syntax for creating a null initialized array is: New ElementType [ Sizes ] ...where sizes is a comma separated sequence of dimension sizes. The syntax for creating a value initialized array is: New ElementType [ Sizes ] ( Element0 , Element1 , ...etc ) One dimensional arrays can omit sizes when creating a value initialized array: New ElementType [ ] ( Element0 , Element1 , ...etc ) Here are some examples: ' Creates a ten element integer array Local ints : Int [] = New Int [ 10 ] ' Creates a 5 element float array initialized to 1.0,3,5.1,7,9.2 Local flts : = New Float []( 1.0 , 3 , 5.1 , 7 , 9.2 ) 'Creates a 2x2 element float array initialized to 1,2,3,4 Local flts2 : = New Float [ 2 , 2 ]( 1 , 2 , 3 , 4 )","title":"Creating arrays"},{"location":"docs/lang/array/#iterating_through_arrays","text":"You can iterate through the elements of an array using Eachin , eg: Local arr : = New Int []( 1 , 3 , 5 , 7 , 9 ) For Local i : = Eachin arr Print i Next","title":"Iterating through arrays"},{"location":"docs/lang/array/#slicing_arrays","text":"One dimensional arrays can be sliced using the .Slice() method, eg: Local ints : = New Int []( 1 , 3 , 5 , 7 , 9 ) ints = ints . Slice ( 1 , 4 ) ' ints now contains 3,5,7","title":"Slicing arrays"},{"location":"docs/lang/array/#resizing_arrays","text":"One dimensional arrays can be resized using the .Resize() method, eg: Local ints : = New Int []( 1 , 2 , 3 ) ints = ints . Resize ( 5 ) ' ints now contains 1,2,3,0,0 Attention Note that .Resize() actually returns a resized copy of the input array! The input array is not modified in any way. Multidimensional arrays cannot currently be sliced or resized.","title":"Resizing arrays"},{"location":"docs/lang/assets/","text":"Assets # Introduction # Wonkey provides a simple system for managing assets. This allows you to import and use images, files, fonts, and sounds in a consistent way, regardless of the target platform you are deploying to. For the following examples, assume a project folder structure like this: main.wx images/image1.png images/image2.png sounds/sound1.wav sounds/sound2.wav Importing Assets # Import assets for use in your project by using an Import directive. ' individual files # Import \"relative/local/path/to/your/file\" ' entire folders # Import \"relaive/local/path/\" When importing entire folders, make sure to include the trailing slash at the end to let the compiler know it's a folder. ' import the entire images subfolder # Import \"images/\" ' import a specific sound # Import \"sounds/sound1.wav\" These import directives can go anywhere in your source file, but standard practice is to put them at the top of the file. Using Imported Assets # Once you've imported your assets, you can reference them by prefixing the imported filename with asset:: This allows you to use them with a function or method that asks for a String path to a file. # Import \"images/image1.png\" Local myImage : Image = Image . Load ( \"asset::image1.png\" ) If you imported a folder containing several assets, you can reference any of the assets in this way. # Import \"images/\" Local image1 : Image = Image . Load ( \"asset::image1.png\" ) Local image2 : Image = Image . Load ( \"asset::image2.png\" ) Importing into a subfolder with \"@/\" # If you want to maintain a folder structure when importing, you can specify a target subfolder with @/target/path/ after the path in the import directive. ' imports image1.jpg into a subfolder called images # Import \"images/image1.jpg@/images/\" @/ also works when importing entire folders: ' imports everything from images/ into a subfolder called images/ # Import \"images/@/images/\" The destination folder name doesn't have to be the same as the source folder name. ' imports everything from images/ into a subfolder called data/ # Import \"images/@/data/\" When using the files in your code, make sure to add the target subfolder after asset:: , for example: # Import \"images/image1.png@data/\" Local image : Image = Image . Load ( \"asset::data/image1.png\" )","title":"Assets"},{"location":"docs/lang/assets/#assets","text":"","title":"Assets"},{"location":"docs/lang/assets/#introduction","text":"Wonkey provides a simple system for managing assets. This allows you to import and use images, files, fonts, and sounds in a consistent way, regardless of the target platform you are deploying to. For the following examples, assume a project folder structure like this: main.wx images/image1.png images/image2.png sounds/sound1.wav sounds/sound2.wav","title":"Introduction"},{"location":"docs/lang/assets/#importing_assets","text":"Import assets for use in your project by using an Import directive. ' individual files # Import \"relative/local/path/to/your/file\" ' entire folders # Import \"relaive/local/path/\" When importing entire folders, make sure to include the trailing slash at the end to let the compiler know it's a folder. ' import the entire images subfolder # Import \"images/\" ' import a specific sound # Import \"sounds/sound1.wav\" These import directives can go anywhere in your source file, but standard practice is to put them at the top of the file.","title":"Importing Assets"},{"location":"docs/lang/assets/#using_imported_assets","text":"Once you've imported your assets, you can reference them by prefixing the imported filename with asset:: This allows you to use them with a function or method that asks for a String path to a file. # Import \"images/image1.png\" Local myImage : Image = Image . Load ( \"asset::image1.png\" ) If you imported a folder containing several assets, you can reference any of the assets in this way. # Import \"images/\" Local image1 : Image = Image . Load ( \"asset::image1.png\" ) Local image2 : Image = Image . Load ( \"asset::image2.png\" )","title":"Using Imported Assets"},{"location":"docs/lang/assets/#importing_into_a_subfolder_with","text":"If you want to maintain a folder structure when importing, you can specify a target subfolder with @/target/path/ after the path in the import directive. ' imports image1.jpg into a subfolder called images # Import \"images/image1.jpg@/images/\" @/ also works when importing entire folders: ' imports everything from images/ into a subfolder called images/ # Import \"images/@/images/\" The destination folder name doesn't have to be the same as the source folder name. ' imports everything from images/ into a subfolder called data/ # Import \"images/@/data/\" When using the files in your code, make sure to add the target subfolder after asset:: , for example: # Import \"images/image1.png@data/\" Local image : Image = Image . Load ( \"asset::data/image1.png\" )","title":"Importing into a subfolder with \"@/\""},{"location":"docs/lang/cast/","text":"Cast # Type conversions # The Cast<> operator can be used to convert a value of one type to a value of a different type. The syntax of cast is: Case< Type >( Expression ) .","title":"Casting"},{"location":"docs/lang/cast/#cast","text":"","title":"Cast"},{"location":"docs/lang/cast/#type_conversions","text":"The Cast<> operator can be used to convert a value of one type to a value of a different type. The syntax of cast is: Case< Type >( Expression ) .","title":"Type conversions"},{"location":"docs/lang/class-function/","text":"Class functions # Introduction #","title":"Class/Struct Functions"},{"location":"docs/lang/class-function/#class_functions","text":"","title":"Class functions"},{"location":"docs/lang/class-function/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/class/","text":"Class # Introduction # A class is a kind of 'blueprint' for creating objects at runtime. The syntax for declaring a class is: Class Identifier [ < GenericTypeIdents > ] [ Extends SuperClass ] [ Implements Interfaces ] [ Mod ifier ] ... Class Members ... End SuperClass defaults to Object if omitted. Interfaces is a comma separated list of interface types. Modifier can be one of: Abstract - class cannot be instantiated with 'New', it must be extended. Final - class cannot be extended. Classes can contain const, global, field, method and function declarations, as well as other user defined types. Once you have declared a class, you can create objects (or 'instances') of that class at runtime using the New operator. Classes are 'reference types', meaning that class instances are really just a 'handle' or 'pointer' to the actual class data.","title":"Classes"},{"location":"docs/lang/class/#class","text":"","title":"Class"},{"location":"docs/lang/class/#introduction","text":"A class is a kind of 'blueprint' for creating objects at runtime. The syntax for declaring a class is: Class Identifier [ < GenericTypeIdents > ] [ Extends SuperClass ] [ Implements Interfaces ] [ Mod ifier ] ... Class Members ... End SuperClass defaults to Object if omitted. Interfaces is a comma separated list of interface types. Modifier can be one of: Abstract - class cannot be instantiated with 'New', it must be extended. Final - class cannot be extended. Classes can contain const, global, field, method and function declarations, as well as other user defined types. Once you have declared a class, you can create objects (or 'instances') of that class at runtime using the New operator. Classes are 'reference types', meaning that class instances are really just a 'handle' or 'pointer' to the actual class data.","title":"Introduction"},{"location":"docs/lang/comments/","text":"Comments # Line comments # Line comments can be added using the ' character (ASCII-Code: 39, Hex: $27). Everything to the right of a single quote ( ' ), until the end of a line, will be interpreted as a comment. Comments will be ignored during compilation time. ' ' Example showing line comments ' Print \"hello!\" ' this is a line comment Block comments # Multiline comments can be made by using the #Rem and #End preprocessor directives. #Rem initiates a block-comment and #End ends the block. #Rem and #End both need to be at the start of the line. They can not be used within code lines. #Rem This is a multi-line block comment in Wonkey. #End Function Main () Print \"Using #Rem..#End you can write block comments!\" End Wonkeydoc # #Rem and #End can also be used for documentation of source-code. This is especially useful for documenting modules/libraries. A 'wonkeydoc' comment starts with #Rem wonkeydoc and ends with #End . Directly after 'wonkeydoc' follows the short description. The short description ends with the current line: #Rem wonkeydoc Add two integer numbers ...Detailed description... #End Function Add : Int ( a : Int , b : Int ) Return a + b End Directly after the wonkeydoc-block follows the entity to be documented. Wonkeydoc can be used with: Namespaces (currently ignored) Interfaces, Classes, Structs, Enums Functions, Methods, Properties, Fields Aliases, Consts Detailed description # In the detailed description you can use the following special Wonkeydoc entities, each on a separate line: @param name description - used for documenting function/method parameters @return description - used for describing what a function/method returns. @example .. @end - Used for inserting multi-line examples into the docs. Markdown # You can use Markdown syntax for wonkeydoc: ` is used for code blocks * creates lists Including tables # You can create tables using the usual Markdown syntax: | Header Cell 1 | Header Cell 2 | Header Cell 3 |:----------------|:----------------|:--------------- | Row 1, Column 1 | Row 1, Column 2 | Row 1, Column 3 | Row 2, Column 1 | Row 2, Column 2 | Row 2, Column 3 | Row 3, Column 1 | Row 3, Column 2 | Row 3, Column 3 Links # You can use links to other wonkeydocs. Links are enclosed in [[ and ]] . An optional title can be set after a '|' character: [[ link | Title ]] To create a link to another function in the same file you simply use the name of the function: [[FunctionName]] To create a link to a class in another module you use the module name and the full name of the entity, including the namespace: [[mojo:mojo.app.AppInstance|mojo.AppInstance]] [[mojo3d:mojo3d.Renderer|mojo3d.Renderer]] The part after the '|' character is the text that is displayed for the link. Wonkeydoc for overloaded functions/methods # Overloaded functions are not documented separately. Wonkeydoc is written for the first of the overloaded functions/methods and all '@params' are included in this one wonkeydoc. Example: #Rem wonkeydoc Shows a message box The message box is opened in modal mode and the user needs to confirm it by pressing the 'OK' button. @example MsgBox(\"Get ready!\") MsgBox(10,10,\"Oh no, you lost!\") @end @param x the x-position for the window @param y the y-position for the window @param msg The message for the dialog window @return This function does not return a value #End Function MsgBox ( x : Int , y : Int , msg : String ) End Function MsgBox ( msg : String ) End Deprecated docs # Deprecated wonkeydoc is marked with @deprecated : #Rem wonkeydoc @deprecated #End Function old_func () End Hidden docs # To skip the documentation of an entity you can use the short description @hidden : #Rem wonkeydoc @hidden This is not included in the documentation. #End Function xample () End","title":"Comments"},{"location":"docs/lang/comments/#comments","text":"","title":"Comments"},{"location":"docs/lang/comments/#line_comments","text":"Line comments can be added using the ' character (ASCII-Code: 39, Hex: $27). Everything to the right of a single quote ( ' ), until the end of a line, will be interpreted as a comment. Comments will be ignored during compilation time. ' ' Example showing line comments ' Print \"hello!\" ' this is a line comment","title":"Line comments"},{"location":"docs/lang/comments/#block_comments","text":"Multiline comments can be made by using the #Rem and #End preprocessor directives. #Rem initiates a block-comment and #End ends the block. #Rem and #End both need to be at the start of the line. They can not be used within code lines. #Rem This is a multi-line block comment in Wonkey. #End Function Main () Print \"Using #Rem..#End you can write block comments!\" End","title":"Block comments"},{"location":"docs/lang/comments/#wonkeydoc","text":"#Rem and #End can also be used for documentation of source-code. This is especially useful for documenting modules/libraries. A 'wonkeydoc' comment starts with #Rem wonkeydoc and ends with #End . Directly after 'wonkeydoc' follows the short description. The short description ends with the current line: #Rem wonkeydoc Add two integer numbers ...Detailed description... #End Function Add : Int ( a : Int , b : Int ) Return a + b End Directly after the wonkeydoc-block follows the entity to be documented. Wonkeydoc can be used with: Namespaces (currently ignored) Interfaces, Classes, Structs, Enums Functions, Methods, Properties, Fields Aliases, Consts","title":"Wonkeydoc"},{"location":"docs/lang/comments/#detailed_description","text":"In the detailed description you can use the following special Wonkeydoc entities, each on a separate line: @param name description - used for documenting function/method parameters @return description - used for describing what a function/method returns. @example .. @end - Used for inserting multi-line examples into the docs.","title":"Detailed description"},{"location":"docs/lang/comments/#markdown","text":"You can use Markdown syntax for wonkeydoc: ` is used for code blocks * creates lists","title":"Markdown"},{"location":"docs/lang/comments/#including_tables","text":"You can create tables using the usual Markdown syntax: | Header Cell 1 | Header Cell 2 | Header Cell 3 |:----------------|:----------------|:--------------- | Row 1, Column 1 | Row 1, Column 2 | Row 1, Column 3 | Row 2, Column 1 | Row 2, Column 2 | Row 2, Column 3 | Row 3, Column 1 | Row 3, Column 2 | Row 3, Column 3","title":"Including tables"},{"location":"docs/lang/comments/#links","text":"You can use links to other wonkeydocs. Links are enclosed in [[ and ]] . An optional title can be set after a '|' character: [[ link | Title ]] To create a link to another function in the same file you simply use the name of the function: [[FunctionName]] To create a link to a class in another module you use the module name and the full name of the entity, including the namespace: [[mojo:mojo.app.AppInstance|mojo.AppInstance]] [[mojo3d:mojo3d.Renderer|mojo3d.Renderer]] The part after the '|' character is the text that is displayed for the link.","title":"Links"},{"location":"docs/lang/comments/#wonkeydoc_for_overloaded_functionsmethods","text":"Overloaded functions are not documented separately. Wonkeydoc is written for the first of the overloaded functions/methods and all '@params' are included in this one wonkeydoc. Example: #Rem wonkeydoc Shows a message box The message box is opened in modal mode and the user needs to confirm it by pressing the 'OK' button. @example MsgBox(\"Get ready!\") MsgBox(10,10,\"Oh no, you lost!\") @end @param x the x-position for the window @param y the y-position for the window @param msg The message for the dialog window @return This function does not return a value #End Function MsgBox ( x : Int , y : Int , msg : String ) End Function MsgBox ( msg : String ) End","title":"Wonkeydoc for overloaded functions/methods"},{"location":"docs/lang/comments/#deprecated_docs","text":"Deprecated wonkeydoc is marked with @deprecated : #Rem wonkeydoc @deprecated #End Function old_func () End","title":"Deprecated docs"},{"location":"docs/lang/comments/#hidden_docs","text":"To skip the documentation of an entity you can use the short description @hidden : #Rem wonkeydoc @hidden This is not included in the documentation. #End Function xample () End","title":"Hidden docs"},{"location":"docs/lang/compound-types/","text":"Compound types # Introduction #","title":"Overview"},{"location":"docs/lang/compound-types/#compound_types","text":"","title":"Compound types"},{"location":"docs/lang/compound-types/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/conditional-statements/","text":"Conditional statements # If # The If statement allows you to conditionally execute a block of statements depending on the result of a series of boolean expressions. The first boolean expression that evaluates to true will cause the associated block of statements to be executed. No further boolean expressions will be evaluated. If no boolean expression evaluates to True, then the final else block will be executed if present. The syntax for the If statement is: If expression [ Then ] Statements... ElseIf expression [ Then ] Statements... Else Statements... EndIf There may be any number of ElseIf blocks, or none. The final Else block is optional. End or End If may be used instead of EndIf , and Else If may be used instead of ElseIf . In addition, a simple one line version of If is also supported: If Expression [ Then ] Statement [ Else Statement ] Select # The Select statement allows you to execute a block of statements depending on a series of comparisons. The first comparison to produce a match will cause the associated block of statements to be executed. If no comparisons produce a match, then the final Default block will be executed if present. The syntax for the Select statement is: Select Expression Case Expression [ , Expression... ] Statements... Default Statements... End [ Select ] There may be any number of Case blocks, or none. The final Default block is optional. If the default block is present, it must appear after all Case blocks. ? Else # The ? Else operator is used to assign a value with a condition: variable = Expression ? Expression-A Else Expression-B The variable will receive the value of Expression-A if Expression is True, else it will receive the value of Expression-B . The following example: i = j>2 ? 5 Else j+7 is the same as writing: If j > 2 i = 5 Else i = j + 7 EndIf ?Else # The 'Elvis operator' ?Else can be used to return an alternate value if an expression is null. variable = Expression ?Else Expression-B For example: r = x ?Else -1 This will assign the value of x to r if x is non-null. Otherwise it will assign the value -1 to r .","title":"Conditional statements"},{"location":"docs/lang/conditional-statements/#conditional_statements","text":"","title":"Conditional statements"},{"location":"docs/lang/conditional-statements/#if","text":"The If statement allows you to conditionally execute a block of statements depending on the result of a series of boolean expressions. The first boolean expression that evaluates to true will cause the associated block of statements to be executed. No further boolean expressions will be evaluated. If no boolean expression evaluates to True, then the final else block will be executed if present. The syntax for the If statement is: If expression [ Then ] Statements... ElseIf expression [ Then ] Statements... Else Statements... EndIf There may be any number of ElseIf blocks, or none. The final Else block is optional. End or End If may be used instead of EndIf , and Else If may be used instead of ElseIf . In addition, a simple one line version of If is also supported: If Expression [ Then ] Statement [ Else Statement ]","title":"If"},{"location":"docs/lang/conditional-statements/#select","text":"The Select statement allows you to execute a block of statements depending on a series of comparisons. The first comparison to produce a match will cause the associated block of statements to be executed. If no comparisons produce a match, then the final Default block will be executed if present. The syntax for the Select statement is: Select Expression Case Expression [ , Expression... ] Statements... Default Statements... End [ Select ] There may be any number of Case blocks, or none. The final Default block is optional. If the default block is present, it must appear after all Case blocks.","title":"Select"},{"location":"docs/lang/conditional-statements/#else","text":"The ? Else operator is used to assign a value with a condition: variable = Expression ? Expression-A Else Expression-B The variable will receive the value of Expression-A if Expression is True, else it will receive the value of Expression-B . The following example: i = j>2 ? 5 Else j+7 is the same as writing: If j > 2 i = 5 Else i = j + 7 EndIf","title":"? Else"},{"location":"docs/lang/conditional-statements/#else_1","text":"The 'Elvis operator' ?Else can be used to return an alternate value if an expression is null. variable = Expression ?Else Expression-B For example: r = x ?Else -1 This will assign the value of x to r if x is non-null. Otherwise it will assign the value -1 to r .","title":"?Else"},{"location":"docs/lang/conversion-operators/","text":"Conversion Operators # Introduction # You can also add 'conversion operators' to classes and structs. These allow you to convert from a custom class or struct type to an unrelated type, such as another class or struct type, or a primitive type such as String. The syntax for declaring a conversion operator is: Operator To [ < GenericTypeIdents > ] : Type () ... Statements ... End Conversion operators cannot be used to convert a class type to a base class type, or from any type to bool. For example, we can add a string conversion operator to a class like this: Struct Vec2 Field x : Float Field y : Float Method New ( x : Float , y : Float ) Self . x = x Self . y = y End Method ToString : String () Return \"Vec2(\" + x + \",\" + y + \")\" End ' The string conversion operator Operator To : String () Return \"Vec2(\" + x + \",\" + y + \")\" End End This will allow Vec2 values to be implictly converted to strings where possible, for example: Local v : = New Vec2 Print v We no longer need to use '.ToString()' when printing the string. Since Print() takes a string argument, and Vec2 has a conversion operator that returns a string, the conversion operator is automatically called for you.","title":"Conversion Operators"},{"location":"docs/lang/conversion-operators/#conversion_operators","text":"","title":"Conversion Operators"},{"location":"docs/lang/conversion-operators/#introduction","text":"You can also add 'conversion operators' to classes and structs. These allow you to convert from a custom class or struct type to an unrelated type, such as another class or struct type, or a primitive type such as String. The syntax for declaring a conversion operator is: Operator To [ < GenericTypeIdents > ] : Type () ... Statements ... End Conversion operators cannot be used to convert a class type to a base class type, or from any type to bool. For example, we can add a string conversion operator to a class like this: Struct Vec2 Field x : Float Field y : Float Method New ( x : Float , y : Float ) Self . x = x Self . y = y End Method ToString : String () Return \"Vec2(\" + x + \",\" + y + \")\" End ' The string conversion operator Operator To : String () Return \"Vec2(\" + x + \",\" + y + \")\" End End This will allow Vec2 values to be implictly converted to strings where possible, for example: Local v : = New Vec2 Print v We no longer need to use '.ToString()' when printing the string. Since Print() takes a string argument, and Vec2 has a conversion operator that returns a string, the conversion operator is automatically called for you.","title":"Introduction"},{"location":"docs/lang/datatypes/","text":"Built-in data types # Primitive types # The following primtive types are supported: Type Name Description Storage Size Range (Dec) Void No type. - - Bool Boolean type. ? '0' or '<> 0' True or False Byte 8 bit signed integer. 1 Byte -128 - 127 UByte 8 bit unsigned integer. 1 Byte 0 - 255 Short 16 bit signed integer. 2 Bytes -32.768 - 32.767 UShort 16 bit unsigned integer. 2 Bytes 0 - 65.535 Int 32 bit signed integer. 4 Bytes -2.147.483.648 - 2.147.483.647 UInt 32 bit unsigned integer. 4 Bytes 0 - 4.294.967.295 Long 64 bit signed integer. 8 Bytes -9.223.372.036.854.775.808 - 9.223.372.036.854.775.807 ULong 64 bit unsigned integer. 8 Bytes 0 - 18.446.744.073.709.551.615 Float 32 bit floating point. 4 Bytes 1.2E-38 - 3.4E+38 (Precision: 6 decimal places) Double 64 bit floating point. 8 Bytes 2.3E-308 - 1.7E+308 (Precision: 15 decimal places) String String of 16 bit characters. 2 Bytes (each char) 0 - 65.535 (each char) Object Base type of all objects. - - Compound types # The following compound types are supported: Type Syntax Description ElementType [] Array type. PointeeType Ptr Pointer type. ReturnType ( ParameterTypes ) Function type. Array types can have more than one dimension, for example: [,] declares a 2D array, [,,] declares a 3D array and so on. The parameter types for a function type can optionally include an identifier prefix, for example: MyFunction:Int( arg:Int ) . The prefix must be a valid identifier but is otherwise ignored. Implicit type conversions # These type conversions are performed automatically: Source type Destination type Bool String Any numeric type Bool , String or any numeric type. String or any array type Bool Any pointer type Void Ptr Class, interface or struct type Bool Class or interface type Base class or implemented interface type Enum type Bool or any integral type. When numeric values are converted to bool, the result will be true if the value is not equal to 0. When strings and arrays are converted to bool, the result will be true if the length of the string or array is not 0. When class or interface instances are converted to bool, the result will be true if the instance is not equal to null. When struct values are converted to bool, the result will be true if the struct value is not equal to null. When floating point values are converted to integral values, the fractional part of the floating point value is chopped off - no rounding is performed. When bools are converted to strings, the result will be either \"True\" or \"False\". Explicit type conversions # Some type conversions must be explicitly performed using the 'cast' operator. The cast operator has the syntax: Cast<DestinationType>(SourceExpression) You must use the cast operator to perform the following type conversions: Source type Destination type Bool Any numeric type String Any numeric type Any pointer type Any pointer type or any integral type Any integral type Any pointer type or any enum type. Class type Derived class or any interface type. Interface type Any class or interface type. When using the cast operator to dynamically downcast an object or interface instance, the result will be Null if the cast failed. When casting bool values to a numeric type, the result will be 1 for true, 0 for false. You can also use 'function syntax' to explictly cast values to primitive types: Local floatValue : Float = 3.14 Local intValue : = Int ( floatValue )","title":"Basic types"},{"location":"docs/lang/datatypes/#built-in_data_types","text":"","title":"Built-in data types"},{"location":"docs/lang/datatypes/#primitive_types","text":"The following primtive types are supported: Type Name Description Storage Size Range (Dec) Void No type. - - Bool Boolean type. ? '0' or '<> 0' True or False Byte 8 bit signed integer. 1 Byte -128 - 127 UByte 8 bit unsigned integer. 1 Byte 0 - 255 Short 16 bit signed integer. 2 Bytes -32.768 - 32.767 UShort 16 bit unsigned integer. 2 Bytes 0 - 65.535 Int 32 bit signed integer. 4 Bytes -2.147.483.648 - 2.147.483.647 UInt 32 bit unsigned integer. 4 Bytes 0 - 4.294.967.295 Long 64 bit signed integer. 8 Bytes -9.223.372.036.854.775.808 - 9.223.372.036.854.775.807 ULong 64 bit unsigned integer. 8 Bytes 0 - 18.446.744.073.709.551.615 Float 32 bit floating point. 4 Bytes 1.2E-38 - 3.4E+38 (Precision: 6 decimal places) Double 64 bit floating point. 8 Bytes 2.3E-308 - 1.7E+308 (Precision: 15 decimal places) String String of 16 bit characters. 2 Bytes (each char) 0 - 65.535 (each char) Object Base type of all objects. - -","title":"Primitive types"},{"location":"docs/lang/datatypes/#compound_types","text":"The following compound types are supported: Type Syntax Description ElementType [] Array type. PointeeType Ptr Pointer type. ReturnType ( ParameterTypes ) Function type. Array types can have more than one dimension, for example: [,] declares a 2D array, [,,] declares a 3D array and so on. The parameter types for a function type can optionally include an identifier prefix, for example: MyFunction:Int( arg:Int ) . The prefix must be a valid identifier but is otherwise ignored.","title":"Compound types"},{"location":"docs/lang/datatypes/#implicit_type_conversions","text":"These type conversions are performed automatically: Source type Destination type Bool String Any numeric type Bool , String or any numeric type. String or any array type Bool Any pointer type Void Ptr Class, interface or struct type Bool Class or interface type Base class or implemented interface type Enum type Bool or any integral type. When numeric values are converted to bool, the result will be true if the value is not equal to 0. When strings and arrays are converted to bool, the result will be true if the length of the string or array is not 0. When class or interface instances are converted to bool, the result will be true if the instance is not equal to null. When struct values are converted to bool, the result will be true if the struct value is not equal to null. When floating point values are converted to integral values, the fractional part of the floating point value is chopped off - no rounding is performed. When bools are converted to strings, the result will be either \"True\" or \"False\".","title":"Implicit type conversions"},{"location":"docs/lang/datatypes/#explicit_type_conversions","text":"Some type conversions must be explicitly performed using the 'cast' operator. The cast operator has the syntax: Cast<DestinationType>(SourceExpression) You must use the cast operator to perform the following type conversions: Source type Destination type Bool Any numeric type String Any numeric type Any pointer type Any pointer type or any integral type Any integral type Any pointer type or any enum type. Class type Derived class or any interface type. Interface type Any class or interface type. When using the cast operator to dynamically downcast an object or interface instance, the result will be Null if the cast failed. When casting bool values to a numeric type, the result will be 1 for true, 0 for false. You can also use 'function syntax' to explictly cast values to primitive types: Local floatValue : Float = 3.14 Local intValue : = Int ( floatValue )","title":"Explicit type conversions"},{"location":"docs/lang/encapsulation/","text":"Encapsulation # Introduction # There are three levels of encapsulation for class and struct members: Public members can be accessed from anywhere. It is the default encapsulation level. Protected members can only be accessed by the base class and the derived ones or by class/struct extensions. Code existing in the same source file have acces to Protected members too. Private members can only be accessed by the base class. Code existing in the same source file have acces to Private members too. There is also the Internal privacy level, used to declare module internal accessibility. Example: Class Foo ' public by default Field i : Int Protected Field someProtectedThing : Int Method doSomething () Print \"Doing something\" End Private Field _somePrivateThing : String End","title":"Encapsulation"},{"location":"docs/lang/encapsulation/#encapsulation","text":"","title":"Encapsulation"},{"location":"docs/lang/encapsulation/#introduction","text":"There are three levels of encapsulation for class and struct members: Public members can be accessed from anywhere. It is the default encapsulation level. Protected members can only be accessed by the base class and the derived ones or by class/struct extensions. Code existing in the same source file have acces to Protected members too. Private members can only be accessed by the base class. Code existing in the same source file have acces to Private members too. There is also the Internal privacy level, used to declare module internal accessibility. Example: Class Foo ' public by default Field i : Int Protected Field someProtectedThing : Int Method doSomething () Print \"Doing something\" End Private Field _somePrivateThing : String End","title":"Introduction"},{"location":"docs/lang/enum/","text":"Enum # Introduction # An enum is a user defined data type that contains a set of named integer constants. Enums are frequently used to implement typesafe 'flags' or 'bitmasks'. Unintialized enum members are automatically assigned constant integer values starting with 0 and increasing by 1 for each successive enum member: Enum MyEnum A , B , C ' A, B, C will be assigned the values 0, 1, 2 D , E , F ' D, E, F will be assigned the values 4, 5, 6 End You can also initialize enum members with a constant integer value: Enum MyEnum A = 10 , B = 20 , C = 30 ' A, B, C will be assigned the values 10, 20, 30 D , E , F ' D, E, F will be assigned the values 31, 32, 33 End Enum members are accessed using the 'dot' operator: Local e : MyEnum = MyEnum . A Enum values can be implictly converted to any integer type, and can be used with the & (bitwise 'and'), | (bitwise 'or') and ~ (bitwise 'exclusive-or') binary operators. This allows you to use enums to represent 'bitmasks'. Enum values can also be compared with enum values of the same type, or with a Null which represents an enum value with the integer value 0.","title":"Enums"},{"location":"docs/lang/enum/#enum","text":"","title":"Enum"},{"location":"docs/lang/enum/#introduction","text":"An enum is a user defined data type that contains a set of named integer constants. Enums are frequently used to implement typesafe 'flags' or 'bitmasks'. Unintialized enum members are automatically assigned constant integer values starting with 0 and increasing by 1 for each successive enum member: Enum MyEnum A , B , C ' A, B, C will be assigned the values 0, 1, 2 D , E , F ' D, E, F will be assigned the values 4, 5, 6 End You can also initialize enum members with a constant integer value: Enum MyEnum A = 10 , B = 20 , C = 30 ' A, B, C will be assigned the values 10, 20, 30 D , E , F ' D, E, F will be assigned the values 31, 32, 33 End Enum members are accessed using the 'dot' operator: Local e : MyEnum = MyEnum . A Enum values can be implictly converted to any integer type, and can be used with the & (bitwise 'and'), | (bitwise 'or') and ~ (bitwise 'exclusive-or') binary operators. This allows you to use enums to represent 'bitmasks'. Enum values can also be compared with enum values of the same type, or with a Null which represents an enum value with the integer value 0.","title":"Introduction"},{"location":"docs/lang/error-handling/","text":"Error handling # Exceptions # A Try/Catch block is an error-handling construct that allows custom code to be executed in situations which may otherwise cause undesirable behaviour. The Try/Catch block opens with Try and closes with End (or End Try). The code to be executed within must be followed by at least one Catch section. In the event of an error occurring within the Try/Catch block, an exception object (based on the native Throwable class) should be 'thrown' via the Throw instruction. If an exception occurs, program flow jumps to a Catch section declared explicitly for the given exception type. The exception object is 'caught' and the relevant error-handling code is executed. You can declare multiple exception classes to handle different types of exception and should create a matching Catch section for each one. After an exception is caught and handled, program flow exits the Try/Catch block and continues. When a Try block has multiple Catch blocks and an exception is thrown, the first Catch block capable of handling the exception is executed. If no suitable Catch block can be found, the exception is passed to the next most recently executed Try block, and so on. If no Catch block can be found to catch an exception, a runtime error occurs and the application is terminated. The Try/Catch method of error-handling allows code to be written without the need to manually check for errors at each step, provided an exception has been set up to handle any errors that are likely to be encountered. Syntax: Try ...code (sould contain at least one 'throw')... Catch exception ...error handling code... End Example code: # Import \"<std>\" Using std .. Class CustomException Extends Throwable Field msg : String Method New ( message : String ) Self . msg = message End End Function Main : Void () Local somethingWrong : = True Try If somethingWrong Then Throw New CustomException ( \"Custom Exception detected\" ) Catch err : CustomException Print err . msg End End","title":"Error handling"},{"location":"docs/lang/error-handling/#error_handling","text":"","title":"Error handling"},{"location":"docs/lang/error-handling/#exceptions","text":"A Try/Catch block is an error-handling construct that allows custom code to be executed in situations which may otherwise cause undesirable behaviour. The Try/Catch block opens with Try and closes with End (or End Try). The code to be executed within must be followed by at least one Catch section. In the event of an error occurring within the Try/Catch block, an exception object (based on the native Throwable class) should be 'thrown' via the Throw instruction. If an exception occurs, program flow jumps to a Catch section declared explicitly for the given exception type. The exception object is 'caught' and the relevant error-handling code is executed. You can declare multiple exception classes to handle different types of exception and should create a matching Catch section for each one. After an exception is caught and handled, program flow exits the Try/Catch block and continues. When a Try block has multiple Catch blocks and an exception is thrown, the first Catch block capable of handling the exception is executed. If no suitable Catch block can be found, the exception is passed to the next most recently executed Try block, and so on. If no Catch block can be found to catch an exception, a runtime error occurs and the application is terminated. The Try/Catch method of error-handling allows code to be written without the need to manually check for errors at each step, provided an exception has been set up to handle any errors that are likely to be encountered. Syntax: Try ...code (sould contain at least one 'throw')... Catch exception ...error handling code... End Example code: # Import \"<std>\" Using std .. Class CustomException Extends Throwable Field msg : String Method New ( message : String ) Self . msg = message End End Function Main : Void () Local somethingWrong : = True Try If somethingWrong Then Throw New CustomException ( \"Custom Exception detected\" ) Catch err : CustomException Print err . msg End End","title":"Exceptions"},{"location":"docs/lang/expressions/","text":"Expressions # Introduction # An expression is a sequence of operations that produces a result. Expressions are formed by combining operators with operands, with the operands themselves being expression (often known as 'sub-expressions'). All expressions have a 'type', for example, the type of the expression '5' is 'Int'. The type of an expression depends on the type of its operands.","title":"Overview"},{"location":"docs/lang/expressions/#expressions","text":"","title":"Expressions"},{"location":"docs/lang/expressions/#introduction","text":"An expression is a sequence of operations that produces a result. Expressions are formed by combining operators with operands, with the operands themselves being expression (often known as 'sub-expressions'). All expressions have a 'type', for example, the type of the expression '5' is 'Int'. The type of an expression depends on the type of its operands.","title":"Introduction"},{"location":"docs/lang/extends/","text":"Extends # Introduction # Inheritance #","title":"Inheritance"},{"location":"docs/lang/extends/#extends","text":"","title":"Extends"},{"location":"docs/lang/extends/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/extends/#inheritance","text":"","title":"Inheritance"},{"location":"docs/lang/extension/","text":"Extension # Introduction # Extensions allow you to add extra methods and functions to existing classes or structs. Fields cannot be added this way. Private members cannot be accessed by extensions. Struct Foo Field i : Int = 0 End Struct Foo Extension Method Increment () i += 1 End End","title":"Extensions"},{"location":"docs/lang/extension/#extension","text":"","title":"Extension"},{"location":"docs/lang/extension/#introduction","text":"Extensions allow you to add extra methods and functions to existing classes or structs. Fields cannot be added this way. Private members cannot be accessed by extensions. Struct Foo Field i : Int = 0 End Struct Foo Extension Method Increment () i += 1 End End","title":"Introduction"},{"location":"docs/lang/field/","text":"Field # Introduction # Fields are variables that live inside the memory allocated for an instance of a class or struct. To declare a field variable: Field identifier : Type [ = Expression ] ...or... Field identifier : = Expression For struct fields, Expression must not contain any code that has side effects.","title":"Fields"},{"location":"docs/lang/field/#field","text":"","title":"Field"},{"location":"docs/lang/field/#introduction","text":"Fields are variables that live inside the memory allocated for an instance of a class or struct. To declare a field variable: Field identifier : Type [ = Expression ] ...or... Field identifier : = Expression For struct fields, Expression must not contain any code that has side effects.","title":"Introduction"},{"location":"docs/lang/function-overloading/","text":"Function overloading # Introduction #","title":"Function overloading"},{"location":"docs/lang/function-overloading/#function_overloading","text":"","title":"Function overloading"},{"location":"docs/lang/function-overloading/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/function-values/","text":"Function values # Introduction # Wonkey supports 'first class' functions. This means function 'values' can be stored in variables and arrays, passed to other functions and returned from functions.","title":"Function values"},{"location":"docs/lang/function-values/#function_values","text":"","title":"Function values"},{"location":"docs/lang/function-values/#introduction","text":"Wonkey supports 'first class' functions. This means function 'values' can be stored in variables and arrays, passed to other functions and returned from functions.","title":"Introduction"},{"location":"docs/lang/function/","text":"Function # Global Functions # To declare a global function: Function Identifier [ GenericParams ] [ : ReturnType ] ( Parameters ) ...Statements... End ReturnType defaults to Void if omitted. Parameters is a comma separated list of parameter declarations. Class methods # The syntax for declaring a class method is: Method Identifier [ GenericParams ] [ : ReturnType ] ( Parameters ) [ Virtual | Abstract | Override | Final | Override Final ] ...Statements... End If a method is declared Virtual or Abstract , it can be overriden by methods in derived classes. Overriding methods must have the same return type and parameter types as the class method, and must be declared Override . If a method is declared Abstract , no implementation may be provided (ie: no 'statements' or 'End'). Such a method must be overriden by a method in a derived class, and also makes its enclosing class implictly abstract (an abstract class cannot be instantiated). If a method is declared Override or Override Final , it must override a virtual method in a base class. If a method is declared Final or Override Final , it cannot be overriden by any methods in derived classes. By default, class methods are final. Function values # Wonkey supports 'first class' functions. This means function 'values' can be stored in variables and arrays, passed to other functions and returned from functions.","title":"Global functions"},{"location":"docs/lang/function/#function","text":"","title":"Function"},{"location":"docs/lang/function/#global_functions","text":"To declare a global function: Function Identifier [ GenericParams ] [ : ReturnType ] ( Parameters ) ...Statements... End ReturnType defaults to Void if omitted. Parameters is a comma separated list of parameter declarations.","title":"Global Functions"},{"location":"docs/lang/function/#class_methods","text":"The syntax for declaring a class method is: Method Identifier [ GenericParams ] [ : ReturnType ] ( Parameters ) [ Virtual | Abstract | Override | Final | Override Final ] ...Statements... End If a method is declared Virtual or Abstract , it can be overriden by methods in derived classes. Overriding methods must have the same return type and parameter types as the class method, and must be declared Override . If a method is declared Abstract , no implementation may be provided (ie: no 'statements' or 'End'). Such a method must be overriden by a method in a derived class, and also makes its enclosing class implictly abstract (an abstract class cannot be instantiated). If a method is declared Override or Override Final , it must override a virtual method in a base class. If a method is declared Final or Override Final , it cannot be overriden by any methods in derived classes. By default, class methods are final.","title":"Class methods"},{"location":"docs/lang/function/#function_values","text":"Wonkey supports 'first class' functions. This means function 'values' can be stored in variables and arrays, passed to other functions and returned from functions.","title":"Function values"},{"location":"docs/lang/generic-class/","text":"Generic Class # Introduction #","title":"Generic Class"},{"location":"docs/lang/generic-class/#generic_class","text":"","title":"Generic Class"},{"location":"docs/lang/generic-class/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/generic-function/","text":"Generic Function # Introduction #","title":"Generic Function"},{"location":"docs/lang/generic-function/#generic_function","text":"","title":"Generic Function"},{"location":"docs/lang/generic-function/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/generic-interface/","text":"Generic Interface # Introduction #","title":"Generic Interface"},{"location":"docs/lang/generic-interface/#generic_interface","text":"","title":"Generic Interface"},{"location":"docs/lang/generic-interface/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/generic-struct/","text":"Generic Struct # Introduction #","title":"Generic Struct"},{"location":"docs/lang/generic-struct/#generic_struct","text":"","title":"Generic Struct"},{"location":"docs/lang/generic-struct/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/generics/","text":"Generic programming # Introduction #","title":"Overview"},{"location":"docs/lang/generics/#generic_programming","text":"","title":"Generic programming"},{"location":"docs/lang/generics/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/import/","text":"Import # Introduction # Wonkey includes a simple build system that converts wonkey files to C++, compiles the C++ code, and links the resultant object files. The build system allows you to import *.wx files and several types of non-Wonkey files into a project for compilation and/or linking. This is done using a system import directive: # Import \"<system_file>\" ...or a local import directive: # Import \"local_file\" Import directives can appear any where in a Wonkey source file, but it's generally tidiest if they are placed at the top of the file. System Imports # System files are files that are generally provided with the compiler toolset, and that the compiler and/or linker are configured to find automatically. Wonkey recognizes the following system file types: System file type suffix System file type .wx Wonkey module. .o, .obj, .a, .lib Static library. .so, .dll, .dylib Dynamic library. .framework MacOS framework. .h, .hh, .hpp C/C++/Objective C header. Note that system file names are enclosed by < and > characters, while local file names are not. An example of importing a system library: # Import \"<wsock32.a>\" If no extension is provided for a system import, Wonkey will assume you are importing a wonkey module, eg: # Import \"<std>\" This will import the wonkey 'std' module. This is effectively the same as: # Import \"<std.wx>\" Local Imports # Local files are files that are located relative to the Wonkey file that imports them. Wonkey recognizes the following local file types: Local file type suffix Local file type .wx Wonkey source code. .o, .obj Object file. .a, .lib Static library. .so, .dll, .dylib Dynamic library. .framework MacOS framework. .exe Windows executable. .c, .cc, .cxx, .cpp, .m, .mm C/C++/Objective C source code. .h, .hh, .hpp C/C++/Objective C header. When importing *.wx files, the file extension can be omited: # Import \"player\" ' imports player.wx Import include directories # It is also possible to add local 'include directories', 'library directories' and 'framework directories' with import. This is done using syntax similar to a local import, but replacing the filename with a wildcard. For example, to add an include directory: # Import \"include_directory/*.h\" This will allow you to import any header file inside 'include_directory' using... # Import \"<include_file>\" ...without having to specify the full path of the file. To add a library directory: # Import \"staticlib_directory/*.a\" To add a macOS framework directory: # Import \"framework_directory/*.framework\" Importing Assets # # Import is also used for importing assets like images, sound files, etc. See the topic about Assets for detailed informations.","title":"Imports"},{"location":"docs/lang/import/#import","text":"","title":"Import"},{"location":"docs/lang/import/#introduction","text":"Wonkey includes a simple build system that converts wonkey files to C++, compiles the C++ code, and links the resultant object files. The build system allows you to import *.wx files and several types of non-Wonkey files into a project for compilation and/or linking. This is done using a system import directive: # Import \"<system_file>\" ...or a local import directive: # Import \"local_file\" Import directives can appear any where in a Wonkey source file, but it's generally tidiest if they are placed at the top of the file.","title":"Introduction"},{"location":"docs/lang/import/#system_imports","text":"System files are files that are generally provided with the compiler toolset, and that the compiler and/or linker are configured to find automatically. Wonkey recognizes the following system file types: System file type suffix System file type .wx Wonkey module. .o, .obj, .a, .lib Static library. .so, .dll, .dylib Dynamic library. .framework MacOS framework. .h, .hh, .hpp C/C++/Objective C header. Note that system file names are enclosed by < and > characters, while local file names are not. An example of importing a system library: # Import \"<wsock32.a>\" If no extension is provided for a system import, Wonkey will assume you are importing a wonkey module, eg: # Import \"<std>\" This will import the wonkey 'std' module. This is effectively the same as: # Import \"<std.wx>\"","title":"System Imports"},{"location":"docs/lang/import/#local_imports","text":"Local files are files that are located relative to the Wonkey file that imports them. Wonkey recognizes the following local file types: Local file type suffix Local file type .wx Wonkey source code. .o, .obj Object file. .a, .lib Static library. .so, .dll, .dylib Dynamic library. .framework MacOS framework. .exe Windows executable. .c, .cc, .cxx, .cpp, .m, .mm C/C++/Objective C source code. .h, .hh, .hpp C/C++/Objective C header. When importing *.wx files, the file extension can be omited: # Import \"player\" ' imports player.wx","title":"Local Imports"},{"location":"docs/lang/import/#import_include_directories","text":"It is also possible to add local 'include directories', 'library directories' and 'framework directories' with import. This is done using syntax similar to a local import, but replacing the filename with a wildcard. For example, to add an include directory: # Import \"include_directory/*.h\" This will allow you to import any header file inside 'include_directory' using... # Import \"<include_file>\" ...without having to specify the full path of the file. To add a library directory: # Import \"staticlib_directory/*.a\" To add a macOS framework directory: # Import \"framework_directory/*.framework\"","title":"Import include directories"},{"location":"docs/lang/import/#importing_assets","text":"# Import is also used for importing assets like images, sound files, etc. See the topic about Assets for detailed informations.","title":"Importing Assets"},{"location":"docs/lang/interface/","text":"Interface # Introduction # To declare an interface: Interface Identifier [ < GenericTypeIdents > ] [ Extends Interfaces ] ... Interface members... End Interfaces is a comma separated list of interface types. An interface can contain consts, globals, methods, functions, properties and other user defined types. Interface methods are always 'abstract' and cannot declare any code. Example for using properties in an interface: Interface IExample ' Property with Setter Property IntProp1 ( a : Int ) ' Property with Getter Property IntProp2 : Int () ' Property with Setter + Getter Property IntProp3 : Int () Setter ( a : Int ) End","title":"Interfaces"},{"location":"docs/lang/interface/#interface","text":"","title":"Interface"},{"location":"docs/lang/interface/#introduction","text":"To declare an interface: Interface Identifier [ < GenericTypeIdents > ] [ Extends Interfaces ] ... Interface members... End Interfaces is a comma separated list of interface types. An interface can contain consts, globals, methods, functions, properties and other user defined types. Interface methods are always 'abstract' and cannot declare any code. Example for using properties in an interface: Interface IExample ' Property with Setter Property IntProp1 ( a : Int ) ' Property with Getter Property IntProp2 : Int () ' Property with Setter + Getter Property IntProp3 : Int () Setter ( a : Int ) End","title":"Introduction"},{"location":"docs/lang/lambda/","text":"Lambda # Introduction # Lambda functions # To declare a lambda function: Lambda [ : ReturnType ] ( Parameters ) ...Statements... End Lambda declarations must appear within an expression, and therefore should not start on a new line. For example: Local myLambda : = Lambda () Print \"My Lambda!\" End myLambda () To pass a lambda to a function: SomeFunc ( Lambda () Print \"MyLambda\" End ) Note the closing ) after the End to match the opening ( after SomeFunc .","title":"Lambda functions"},{"location":"docs/lang/lambda/#lambda","text":"","title":"Lambda"},{"location":"docs/lang/lambda/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/lambda/#lambda_functions","text":"To declare a lambda function: Lambda [ : ReturnType ] ( Parameters ) ...Statements... End Lambda declarations must appear within an expression, and therefore should not start on a new line. For example: Local myLambda : = Lambda () Print \"My Lambda!\" End myLambda () To pass a lambda to a function: SomeFunc ( Lambda () Print \"MyLambda\" End ) Note the closing ) after the End to match the opening ( after SomeFunc .","title":"Lambda functions"},{"location":"docs/lang/loop-statements/","text":"Loop statements # While # The While loop allows you to execute a block of statements repeatedly while a boolean expression evaluates to true. Note that a While loop may never actually execute any of it's statements if the expression evaluates to false when the loop is entered. The syntax for the While loop is: While Expression Statements ... Wend End or End While may be used instead of Wend . Exit and Continue may be used within a While loop to abruptly terminate or continue loop execution. Repeat..Until / Forever # Like the While loop, the Repeat loop also allows you to execute a block of statement repeatedly while a boolean expression evaluates to true. However, unlike a While loop, a Repeat loop is guaranteed to execute at least once, as the boolean expression is not evaluated until the end of the loop. The syntax for Repeat / Until loops is: Repeat Statements ... Until Expression ..or.. Repeat Statements ... Forever Exit and Continue may be used within a Repeat loop to abruptly terminate or continue loop execution. For..To # A numeric For loop will continue executing until the value of a numeric index variable reaches an exit value. The index variable is automatically updated every loop iteration by adding a constant step value. The syntax for a numeric For loop is: For [ Local ] IndexVariable [:] = FirstValue To | Until LastValue [ Step StepValue ] Statements ... Next End or End For may be used instead of Next . If present, Local will create a new local index variable that only exists for the duration of the loop. In addition, IndexVariable must include the variable type, or := must be used instead of = to implicitly set the variable's type. If Local is not present, IndexVariable must be a valid, existing variable. The use of To or Until determines whether LastValue should be inclusive or exclusive. If To is used, the loop will exit once the index variable is greater than LastValue (or less than if StepValue is negative). If Until is used, the loop will exit once the index variable is greater than or equal to LastValue (or less than or equal to if StepValue is negative). If omitted, StepValue defaults to 1. Exit and Continue may be used within a numeric For loop to abruptly terminate or continue loop execution. For..Eachin # A For..EachIn loop allows you to iterate through the elements of a collection. A collection is either an array, a string, or a specially designed object. The syntax for a ** For..EachIn loop is: For [ Local ] IndexVariable [:] = EachIn Collection Statements ... Next End or End For may be used instead of Next . If present, Local will create a new local index variable that only exists for the duration of the loop. In addition, IndexVariable must include the variable type, or := must be used instead of = to implicitly set the variable's type. If Local is not present, IndexVariable must be a valid, existing variable. If Collection is an array, the loop will iterate through each element of the array, and the type of the index variable must match the element type of the array. If Collection is a string, the loop will iterate through each character code of the string, and the type of the index variable must be numeric. If Collection is an object, it must implement the std.collections.IContainer interface. Exit # Exit can be used within While , Repeat and For loops to abruptly exit the loop before the loop termination condition has been met. Continue # Continue can be used within While , Repeat and For loops to force the loop to abruptly skip to the next loop iteration, skipping over any statements that may be remaining in the current loop iteration.","title":"Loop statements"},{"location":"docs/lang/loop-statements/#loop_statements","text":"","title":"Loop statements"},{"location":"docs/lang/loop-statements/#while","text":"The While loop allows you to execute a block of statements repeatedly while a boolean expression evaluates to true. Note that a While loop may never actually execute any of it's statements if the expression evaluates to false when the loop is entered. The syntax for the While loop is: While Expression Statements ... Wend End or End While may be used instead of Wend . Exit and Continue may be used within a While loop to abruptly terminate or continue loop execution.","title":"While"},{"location":"docs/lang/loop-statements/#repeatuntil_forever","text":"Like the While loop, the Repeat loop also allows you to execute a block of statement repeatedly while a boolean expression evaluates to true. However, unlike a While loop, a Repeat loop is guaranteed to execute at least once, as the boolean expression is not evaluated until the end of the loop. The syntax for Repeat / Until loops is: Repeat Statements ... Until Expression ..or.. Repeat Statements ... Forever Exit and Continue may be used within a Repeat loop to abruptly terminate or continue loop execution.","title":"Repeat..Until / Forever"},{"location":"docs/lang/loop-statements/#forto","text":"A numeric For loop will continue executing until the value of a numeric index variable reaches an exit value. The index variable is automatically updated every loop iteration by adding a constant step value. The syntax for a numeric For loop is: For [ Local ] IndexVariable [:] = FirstValue To | Until LastValue [ Step StepValue ] Statements ... Next End or End For may be used instead of Next . If present, Local will create a new local index variable that only exists for the duration of the loop. In addition, IndexVariable must include the variable type, or := must be used instead of = to implicitly set the variable's type. If Local is not present, IndexVariable must be a valid, existing variable. The use of To or Until determines whether LastValue should be inclusive or exclusive. If To is used, the loop will exit once the index variable is greater than LastValue (or less than if StepValue is negative). If Until is used, the loop will exit once the index variable is greater than or equal to LastValue (or less than or equal to if StepValue is negative). If omitted, StepValue defaults to 1. Exit and Continue may be used within a numeric For loop to abruptly terminate or continue loop execution.","title":"For..To"},{"location":"docs/lang/loop-statements/#foreachin","text":"A For..EachIn loop allows you to iterate through the elements of a collection. A collection is either an array, a string, or a specially designed object. The syntax for a ** For..EachIn loop is: For [ Local ] IndexVariable [:] = EachIn Collection Statements ... Next End or End For may be used instead of Next . If present, Local will create a new local index variable that only exists for the duration of the loop. In addition, IndexVariable must include the variable type, or := must be used instead of = to implicitly set the variable's type. If Local is not present, IndexVariable must be a valid, existing variable. If Collection is an array, the loop will iterate through each element of the array, and the type of the index variable must match the element type of the array. If Collection is a string, the loop will iterate through each character code of the string, and the type of the index variable must be numeric. If Collection is an object, it must implement the std.collections.IContainer interface.","title":"For..Eachin"},{"location":"docs/lang/loop-statements/#exit","text":"Exit can be used within While , Repeat and For loops to abruptly exit the loop before the loop termination condition has been met.","title":"Exit"},{"location":"docs/lang/loop-statements/#continue","text":"Continue can be used within While , Repeat and For loops to force the loop to abruptly skip to the next loop iteration, skipping over any statements that may be remaining in the current loop iteration.","title":"Continue"},{"location":"docs/lang/method/","text":"Method # Introduction # To declare a method: Method Identifier [ <GenericTypeIdents> ] [ : ReturnType ] ( Arguments ) [ Modifiers ] ...Statements... End ReturnType defaults to Void if omitted. Arguments is a comma separated list of parameter declarations. Modifiers can only be used with class methods, and can be one of: Abstract - method is abstract and has no statements block or End terminator. Any class with an abstract method is implicitly abstract. Virtual - method is virtual and can be dynamically overridden by a subclass method. Override - method is virtual and overrides a super class or interface method. Override Final - method is virtual, overrides a super class or interace method and cannot be overridden by subclasses. Final - method is non-virtual and cannot be overridden by a subclass method. Methods are Final by default.","title":"Methods"},{"location":"docs/lang/method/#method","text":"","title":"Method"},{"location":"docs/lang/method/#introduction","text":"To declare a method: Method Identifier [ <GenericTypeIdents> ] [ : ReturnType ] ( Arguments ) [ Modifiers ] ...Statements... End ReturnType defaults to Void if omitted. Arguments is a comma separated list of parameter declarations. Modifiers can only be used with class methods, and can be one of: Abstract - method is abstract and has no statements block or End terminator. Any class with an abstract method is implicitly abstract. Virtual - method is virtual and can be dynamically overridden by a subclass method. Override - method is virtual and overrides a super class or interface method. Override Final - method is virtual, overrides a super class or interace method and cannot be overridden by subclasses. Final - method is non-virtual and cannot be overridden by a subclass method. Methods are Final by default.","title":"Introduction"},{"location":"docs/lang/misc/","text":"Miscellaneous # Line breaks in code # Lines can currently only be split after \u2018[\u2018, \u2018(\u2018 or \u2018,\u2019 tokens. Local myArray : Int [] = New Int []( 0 , 1 , 2 ) Local myarray2 : String [,] = New String [ 10 , 10 ] Print # Writes a String or a numeric value to the output console. Print \"Hello world\" ' printing a String Print myFloat ' printing a Float Hexadecimal numbers ($) # Hexadecimal numbers can be entered using the $ symbol Local i : = $A0F File privacy levels # Privacy levels can be set at file scope: Public can be accessed from anywhere. It is the default level. Private can be accessed within the file only. Internal can be accessed from the same module only.","title":"Misc"},{"location":"docs/lang/misc/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"docs/lang/misc/#line_breaks_in_code","text":"Lines can currently only be split after \u2018[\u2018, \u2018(\u2018 or \u2018,\u2019 tokens. Local myArray : Int [] = New Int []( 0 , 1 , 2 ) Local myarray2 : String [,] = New String [ 10 , 10 ]","title":"Line breaks in code"},{"location":"docs/lang/misc/#print","text":"Writes a String or a numeric value to the output console. Print \"Hello world\" ' printing a String Print myFloat ' printing a Float","title":"Print"},{"location":"docs/lang/misc/#hexadecimal_numbers","text":"Hexadecimal numbers can be entered using the $ symbol Local i : = $A0F","title":"Hexadecimal numbers ($)"},{"location":"docs/lang/misc/#file_privacy_levels","text":"Privacy levels can be set at file scope: Public can be accessed from anywhere. It is the default level. Private can be accessed within the file only. Internal can be accessed from the same module only.","title":"File privacy levels"},{"location":"docs/lang/modules/","text":"Modules and Applications # Creating modules # A module consists of a sub-directory inside the top level '/modules/' directory, that contains a 'root' Wonkey (.wx) file with the same name as the sub-directory and a 'module.json' file , eg: /modules/my-module/ /modules/my-module/my-module.wx /modules/my-module/module.json Module names can contain any valid identifier or the - character. However, the - character cannot be used twice or more in succession, eg: legal-module-name illegal--module--name Module names live in a 'flat' namespace so should be as unique as possible. The 'module.json' file must contain a json object with the following fields: \"module\" : string - the name of the module. Must be the same as the directory name. \"author\" : string - the author of the module. \"version\" : string - the version of the module. This should be in number 'dot' number 'dot' number format, eg: \"1.0.0\" . \"depends\" : string array - All modules this module depends on. This will generally include all other modukes #imported by the module, eg: [\"libc\",\"std\"] . A simple module.json file might look like this: { \"module\" : \"my-module\", \"version\" : \"1.0.0\", \"depends\" : [\"libc\",\"std\"] } To rebuild a module, use the wake 'mods' option, eg: wake mods my-module This will cause the root 'modules/my-module/my-module.wx' file to be built, along with any local files it imports. You can also rebuild all modules with: wake mods This will use the \"depends\" information in the module.json files to determine the correct order to build the modules in. Modules must not have cyclic dependancies. Each module may also declare a single Main:Void() function that can be used to initialize the module. This function is called after global variables (including global Consts) have been initialized but before the application's Main is called. Since modules can't have cyclic dependencies, Mains will always execute in the correct order, eg: if module X imports module Y, then module Y's Main is guaranteed to be called before module X's. You can use the Internal keyword at class or file scope to declare module internal accessibility. Importing modules # Once built, a module can be imported into other modules using 'import', eg: #Import \"<my-module>\" Applications # An application is really just a special type of module. It doesn't have to reside in the '/modules/' directory, can't be imported by other modules and produces executable files instead of archives, but is otherwise dealt with just like a module. An application must declare a Main:Void() function. Actually, there's no difference between the Main declared in the app, and Mains declared in modules. Since the app depends on ALL modules, and NO modules depend on the app, the app's Main just happens to be the last one called.","title":"Modules"},{"location":"docs/lang/modules/#modules_and_applications","text":"","title":"Modules and Applications"},{"location":"docs/lang/modules/#creating_modules","text":"A module consists of a sub-directory inside the top level '/modules/' directory, that contains a 'root' Wonkey (.wx) file with the same name as the sub-directory and a 'module.json' file , eg: /modules/my-module/ /modules/my-module/my-module.wx /modules/my-module/module.json Module names can contain any valid identifier or the - character. However, the - character cannot be used twice or more in succession, eg: legal-module-name illegal--module--name Module names live in a 'flat' namespace so should be as unique as possible. The 'module.json' file must contain a json object with the following fields: \"module\" : string - the name of the module. Must be the same as the directory name. \"author\" : string - the author of the module. \"version\" : string - the version of the module. This should be in number 'dot' number 'dot' number format, eg: \"1.0.0\" . \"depends\" : string array - All modules this module depends on. This will generally include all other modukes #imported by the module, eg: [\"libc\",\"std\"] . A simple module.json file might look like this: { \"module\" : \"my-module\", \"version\" : \"1.0.0\", \"depends\" : [\"libc\",\"std\"] } To rebuild a module, use the wake 'mods' option, eg: wake mods my-module This will cause the root 'modules/my-module/my-module.wx' file to be built, along with any local files it imports. You can also rebuild all modules with: wake mods This will use the \"depends\" information in the module.json files to determine the correct order to build the modules in. Modules must not have cyclic dependancies. Each module may also declare a single Main:Void() function that can be used to initialize the module. This function is called after global variables (including global Consts) have been initialized but before the application's Main is called. Since modules can't have cyclic dependencies, Mains will always execute in the correct order, eg: if module X imports module Y, then module Y's Main is guaranteed to be called before module X's. You can use the Internal keyword at class or file scope to declare module internal accessibility.","title":"Creating modules"},{"location":"docs/lang/modules/#importing_modules","text":"Once built, a module can be imported into other modules using 'import', eg: #Import \"<my-module>\"","title":"Importing modules"},{"location":"docs/lang/modules/#applications","text":"An application is really just a special type of module. It doesn't have to reside in the '/modules/' directory, can't be imported by other modules and produces executable files instead of archives, but is otherwise dealt with just like a module. An application must declare a Main:Void() function. Actually, there's no difference between the Main declared in the app, and Mains declared in modules. Since the app depends on ALL modules, and NO modules depend on the app, the app's Main just happens to be the last one called.","title":"Applications"},{"location":"docs/lang/namespace/","text":"Namespace # Introduction # All identifiers declared in a Wonkey program file end up inside a 'namespace'. Namespaces are hierarchical, so in addition to identifiers declared by Wonkey code, namespaces can also contain other namespaces. Declaring namespaces # You control which namespace the identifiers declared in a Wonkey file go with the namespace directive: Namespace namespace - path This directive must appear at the top of the program file, before any actual declarations are made. A namespace path is a 'dot' separated sequence of identifiers, eg: wonkey . types std . collections The 'dot' separator indicates the namespace hierarchy, eg: wonkey . types is a 'child' or 'inner' namespace of wonkey . If no namespace is specified in a program file, the identifiers go into a default namespace. This is not recommended though, as the default namespace has no name - so anything inside the default namespace cannot be 'seen' by anything outside. Accessing namespaces # Code can access an identifier in a namespace by prefixing the identifier with the namespace path, eg: Local list : = New std.collections. List < Int > Here, std . collections refers to a namespace, while List is an identifier inside the std . collections namespace. Code inside a particular namespace does not have to use a namespace prefix to find identifiers in the same namespace or in any parent namespace, although it can still do so, eg: Namespace testing Function Test () End Function Main () Test () ' works fine... testing . Test () ' also works... End Using # To make it easier to deal with long or complex namespace paths, the using directive provides a way to add namespace 'search paths' for locating identifiers. The using directive looks like this: Using namespace - path A program can have multiple using directives. Using directives must appear at the top of the program file before any program declarations. Each using directive adds a namespace to a set of 'search paths' that is used to resolve any unknown identifiers in the program code, eg: # Import \"<std>\" Using std . collections Function Main () Local list : = New List < Int > End Without the using directive, this program would fail to compile because the List identifier cannot be found. However, the using direct tells the compiler look for List in the std . collections namespace, where it is successfully located. If you have multiple using directives and an identifier is found in more than one namespace, you will still get a compile error. In this case, you will need to 'fully qualify' the identifier by prefixing it with the correct namespace path. Some modules declare many namespaces, and it can often be difficult to remember where everything is. To deal with this, Wonkey provides a convenient 'double dot' form of Using that will use both a namespace AND all namespaces contained in that namespace. For example: Using std .. The double dots must appear at the end of the using. This will use the std namespace, and the std . collections , std . filesystem etc namespaces too. This works recursively, so any namespaces inside std.collections and std.filesystem are also used. This can of course lead to more 'duplicate identifier' clashes but is none-the-less very convenient.","title":"Namespaces"},{"location":"docs/lang/namespace/#namespace","text":"","title":"Namespace"},{"location":"docs/lang/namespace/#introduction","text":"All identifiers declared in a Wonkey program file end up inside a 'namespace'. Namespaces are hierarchical, so in addition to identifiers declared by Wonkey code, namespaces can also contain other namespaces.","title":"Introduction"},{"location":"docs/lang/namespace/#declaring_namespaces","text":"You control which namespace the identifiers declared in a Wonkey file go with the namespace directive: Namespace namespace - path This directive must appear at the top of the program file, before any actual declarations are made. A namespace path is a 'dot' separated sequence of identifiers, eg: wonkey . types std . collections The 'dot' separator indicates the namespace hierarchy, eg: wonkey . types is a 'child' or 'inner' namespace of wonkey . If no namespace is specified in a program file, the identifiers go into a default namespace. This is not recommended though, as the default namespace has no name - so anything inside the default namespace cannot be 'seen' by anything outside.","title":"Declaring namespaces"},{"location":"docs/lang/namespace/#accessing_namespaces","text":"Code can access an identifier in a namespace by prefixing the identifier with the namespace path, eg: Local list : = New std.collections. List < Int > Here, std . collections refers to a namespace, while List is an identifier inside the std . collections namespace. Code inside a particular namespace does not have to use a namespace prefix to find identifiers in the same namespace or in any parent namespace, although it can still do so, eg: Namespace testing Function Test () End Function Main () Test () ' works fine... testing . Test () ' also works... End","title":"Accessing namespaces"},{"location":"docs/lang/namespace/#using","text":"To make it easier to deal with long or complex namespace paths, the using directive provides a way to add namespace 'search paths' for locating identifiers. The using directive looks like this: Using namespace - path A program can have multiple using directives. Using directives must appear at the top of the program file before any program declarations. Each using directive adds a namespace to a set of 'search paths' that is used to resolve any unknown identifiers in the program code, eg: # Import \"<std>\" Using std . collections Function Main () Local list : = New List < Int > End Without the using directive, this program would fail to compile because the List identifier cannot be found. However, the using direct tells the compiler look for List in the std . collections namespace, where it is successfully located. If you have multiple using directives and an identifier is found in more than one namespace, you will still get a compile error. In this case, you will need to 'fully qualify' the identifier by prefixing it with the correct namespace path. Some modules declare many namespaces, and it can often be difficult to remember where everything is. To deal with this, Wonkey provides a convenient 'double dot' form of Using that will use both a namespace AND all namespaces contained in that namespace. For example: Using std .. The double dots must appear at the end of the using. This will use the std namespace, and the std . collections , std . filesystem etc namespaces too. This works recursively, so any namespaces inside std.collections and std.filesystem are also used. This can of course lead to more 'duplicate identifier' clashes but is none-the-less very convenient.","title":"Using"},{"location":"docs/lang/native-code/","text":"Native code # Integration with native code # In order to allow Wonkey code access to native code, Wonkey provides the 'extern' directive. Extern begins an 'extern block' and must appear at file scope. Extern cannot be used inside a class or function. An extern block is ended by a plain 'public' or 'private' directive. Declarations that appear inside an extern block describe the Wonkey interface to native code. Therefore, functions and methods that appear inside an extern block cannot have any implementation code, as they are already implemented natively. Otherwise, declarations inside an extern block are very similar to normal Wonkey declarations, eg: Extern Struct S Field x : Int Field y : Int Method Update () ' note: no code here - it's already written. Method Render () ' ditto... End Global Counter : Int Function DoSomething ( x : int , y : Int ) You can declare the following inside extern blocks: Consts Globals Structs Classes Functions You cannot declare the following inside extern blocks: Generic functions or types Operator methods Extern symbols # By default, Wonkey will use the name of an extern declaration as its 'symbol'. That is, when Wonkey code that refers to an extern declaration is compiled, it will use the name of the declaration directly in the generated output code. You can modify this behaviour by providing an 'extern symbol' immediately after the declarations type, eg: Extern Global Player : Actor = \"mylib::Player\" Class Actor = \"mylib::Actor\" Method Update () Method Render () Function Clear () = \"mylib::Actor::Clear\" End Extern classes # Extern classes are assumed by default to be real Wonkey classes - that is, they must extend the native wxObject class. However, you can override this by declaring an extern class that extends Void . Objects of such a class are said to be native objects and differ from normal Wonkey object in several ways: A native object is not memory managed in any way. It is up to you to 'delete' or otherwise destroy it. A native object has no runtime type information, so it cannot be downcast using the Cast<> operator.","title":"Native code"},{"location":"docs/lang/native-code/#native_code","text":"","title":"Native code"},{"location":"docs/lang/native-code/#integration_with_native_code","text":"In order to allow Wonkey code access to native code, Wonkey provides the 'extern' directive. Extern begins an 'extern block' and must appear at file scope. Extern cannot be used inside a class or function. An extern block is ended by a plain 'public' or 'private' directive. Declarations that appear inside an extern block describe the Wonkey interface to native code. Therefore, functions and methods that appear inside an extern block cannot have any implementation code, as they are already implemented natively. Otherwise, declarations inside an extern block are very similar to normal Wonkey declarations, eg: Extern Struct S Field x : Int Field y : Int Method Update () ' note: no code here - it's already written. Method Render () ' ditto... End Global Counter : Int Function DoSomething ( x : int , y : Int ) You can declare the following inside extern blocks: Consts Globals Structs Classes Functions You cannot declare the following inside extern blocks: Generic functions or types Operator methods","title":"Integration with native code"},{"location":"docs/lang/native-code/#extern_symbols","text":"By default, Wonkey will use the name of an extern declaration as its 'symbol'. That is, when Wonkey code that refers to an extern declaration is compiled, it will use the name of the declaration directly in the generated output code. You can modify this behaviour by providing an 'extern symbol' immediately after the declarations type, eg: Extern Global Player : Actor = \"mylib::Player\" Class Actor = \"mylib::Actor\" Method Update () Method Render () Function Clear () = \"mylib::Actor::Clear\" End","title":"Extern symbols"},{"location":"docs/lang/native-code/#extern_classes","text":"Extern classes are assumed by default to be real Wonkey classes - that is, they must extend the native wxObject class. However, you can override this by declaring an extern class that extends Void . Objects of such a class are said to be native objects and differ from normal Wonkey object in several ways: A native object is not memory managed in any way. It is up to you to 'delete' or otherwise destroy it. A native object has no runtime type information, so it cannot be downcast using the Cast<> operator.","title":"Extern classes"},{"location":"docs/lang/operator-overloading/","text":"Operator overloading # Introduction # Operator overloading allows you to customize the behavior of the built-in Wonkey operators for classes and structs. You overload an operator by writing an 'operator method', which is effectively just a special kind of method. Operators must appear inside classes/structs - they cannot currently be 'global'. Here is a simple example: Struct Vec2 Field x : Float Field y : Float Method New ( x : Float , y : Float ) Self . x = x Self . y = y End Method ToString : String () Return \"Vec2(\" + x + \",\" + y + \")\" End ' Overload the addition operator. Operator + : Vec2 ( rhs : Vec2 ) Return New Vec2 ( x + rhs . x , y + rhs . y ) End End The 'Operator+' declaration here defines an addition operator for Vec2. This is then used whenever a Vec2 appears as the 'left hand side' of an addition. For example: Function Main () Local v1 : = New Vec2 ( 10.0 , 20.0 ) Local v2 : = New Vec2 ( 30.0 , 40.0 ) Local v3 : = v1 + v2 ' note: calls Operator+ in Vec2. Print v3 . ToString () End The following unary operators can be overloaded: + - ~ The following binary operators can be overloaded: * / Mod + - Shl Shr & | ~ = <> < > <= >= <=> The following assignment operators can be overloaded: *= /= Mod= += -= Shl= Shr= &= |= ~= Indexing behaviour can also be overloaded using [] and []= Note that you cannot overload Not , And , Or or plain assignment = Operators can return any type of value, and can take any type of value for their 'right hand side' argument(s). However, the precedence of operators cannot be changed. The [] and []= operators allow you to define 'indexing' like behaviour. The [] operator is used when an object is indexed, and []= is used when an object is indexed and assigned. Both of these operators can accept any number of parameters of any type. The []= operator requires an additional parameter that is the value to be assigned. This must appear at the end of the parameter list. Here is an example of some indexing operators for the Vec2 class above: Struct Vec2 ... as above ... Operator []: Float ( index : Int ) Assert ( index = 0 Or index = 1 ) If index = 0 Return x Else Return y End Operator [] = ( index : Int , value : Float ) Assert ( index = 0 Or index = 1 ) If index = 0 Then x = value Else y = value End End With these additions, you can access Vec2 coordinates 'by index', eg: Function Main () Local v : = New Vec2 v [ 0 ] = 10.0 v [ 1 ] = 20.0 Print v [ 0 ] Print v [ 1 ] End You can also overload assignment operators, for example: Struct Vec2 ... as above ... Operator += ( v : Vec2 ) x += v . x y += v . y End End If you have already written an Operator+ (as is the case here) this is not strictly necessary, as Wonkey will generate the code for Operator+= for you. However, you may still want to provide a custom version for Operator+= if your code can do so in a more efficient way.","title":"Operator overloading"},{"location":"docs/lang/operator-overloading/#operator_overloading","text":"","title":"Operator overloading"},{"location":"docs/lang/operator-overloading/#introduction","text":"Operator overloading allows you to customize the behavior of the built-in Wonkey operators for classes and structs. You overload an operator by writing an 'operator method', which is effectively just a special kind of method. Operators must appear inside classes/structs - they cannot currently be 'global'. Here is a simple example: Struct Vec2 Field x : Float Field y : Float Method New ( x : Float , y : Float ) Self . x = x Self . y = y End Method ToString : String () Return \"Vec2(\" + x + \",\" + y + \")\" End ' Overload the addition operator. Operator + : Vec2 ( rhs : Vec2 ) Return New Vec2 ( x + rhs . x , y + rhs . y ) End End The 'Operator+' declaration here defines an addition operator for Vec2. This is then used whenever a Vec2 appears as the 'left hand side' of an addition. For example: Function Main () Local v1 : = New Vec2 ( 10.0 , 20.0 ) Local v2 : = New Vec2 ( 30.0 , 40.0 ) Local v3 : = v1 + v2 ' note: calls Operator+ in Vec2. Print v3 . ToString () End The following unary operators can be overloaded: + - ~ The following binary operators can be overloaded: * / Mod + - Shl Shr & | ~ = <> < > <= >= <=> The following assignment operators can be overloaded: *= /= Mod= += -= Shl= Shr= &= |= ~= Indexing behaviour can also be overloaded using [] and []= Note that you cannot overload Not , And , Or or plain assignment = Operators can return any type of value, and can take any type of value for their 'right hand side' argument(s). However, the precedence of operators cannot be changed. The [] and []= operators allow you to define 'indexing' like behaviour. The [] operator is used when an object is indexed, and []= is used when an object is indexed and assigned. Both of these operators can accept any number of parameters of any type. The []= operator requires an additional parameter that is the value to be assigned. This must appear at the end of the parameter list. Here is an example of some indexing operators for the Vec2 class above: Struct Vec2 ... as above ... Operator []: Float ( index : Int ) Assert ( index = 0 Or index = 1 ) If index = 0 Return x Else Return y End Operator [] = ( index : Int , value : Float ) Assert ( index = 0 Or index = 1 ) If index = 0 Then x = value Else y = value End End With these additions, you can access Vec2 coordinates 'by index', eg: Function Main () Local v : = New Vec2 v [ 0 ] = 10.0 v [ 1 ] = 20.0 Print v [ 0 ] Print v [ 1 ] End You can also overload assignment operators, for example: Struct Vec2 ... as above ... Operator += ( v : Vec2 ) x += v . x y += v . y End End If you have already written an Operator+ (as is the case here) this is not strictly necessary, as Wonkey will generate the code for Operator+= for you. However, you may still want to provide a custom version for Operator+= if your code can do so in a more efficient way.","title":"Introduction"},{"location":"docs/lang/operators/","text":"Operators # Introduction # Operator precedence # Operator Description Precedence New New object or array 1 Null Null value Self Self instance Super Super instance True Boolean true False Boolean false Typeof Typeof operator Cast Cast operator Lambda Lambda function identifier Identifier literal Literal value ?. Safe postfix member access 2 . Postfix member acccess ( ) Postfix Invoke [ ] Postfix Index < > Postfix Generic instance Varptr Unary variable address 3 - Unary numeric negate ~ Unary integer complement Not Unary boolean invert * Numeric multiplication 4 / Numeric division Mod Numeric modulo + Numeric addition 5 - Numeric subtraction Shl Integer shift left 6 Shr Integer shift right & Integer and 7 ~ Integer xor \\| Integer or 8 <=> Compare 9 < Less than 10 > Greater than <= Less than or equal >= Greater than or equal = Equal 11 <> Not equal And Boolean and 12 Or Boolean or 13 ? Else If-then-else 14 ?Else 'Elvis operator' The safe member access operator allows you to safely access members of a possibly null object. Accessing a field, property or method of a null object using the plain '.' operator will cause a 'null object runtime error' in debug mode - in release it will likely just crash the program. However, using '?.' instead will cause a null value of the expected type to be returned instead, preventing the runtime error occuring. Note however that this involves some overhead as it means the object must be checked before it is accessed. The 'Elvis operator' is a binary operator that returns its left hand argument if it is non-null, otherwise it returns its right hand argument. It is similar to 'X<>Null ? X Else Null' except that 'X' is only evaluted once.","title":"Operators"},{"location":"docs/lang/operators/#operators","text":"","title":"Operators"},{"location":"docs/lang/operators/#introduction","text":"","title":"Introduction"},{"location":"docs/lang/operators/#operator_precedence","text":"Operator Description Precedence New New object or array 1 Null Null value Self Self instance Super Super instance True Boolean true False Boolean false Typeof Typeof operator Cast Cast operator Lambda Lambda function identifier Identifier literal Literal value ?. Safe postfix member access 2 . Postfix member acccess ( ) Postfix Invoke [ ] Postfix Index < > Postfix Generic instance Varptr Unary variable address 3 - Unary numeric negate ~ Unary integer complement Not Unary boolean invert * Numeric multiplication 4 / Numeric division Mod Numeric modulo + Numeric addition 5 - Numeric subtraction Shl Integer shift left 6 Shr Integer shift right & Integer and 7 ~ Integer xor \\| Integer or 8 <=> Compare 9 < Less than 10 > Greater than <= Less than or equal >= Greater than or equal = Equal 11 <> Not equal And Boolean and 12 Or Boolean or 13 ? Else If-then-else 14 ?Else 'Elvis operator' The safe member access operator allows you to safely access members of a possibly null object. Accessing a field, property or method of a null object using the plain '.' operator will cause a 'null object runtime error' in debug mode - in release it will likely just crash the program. However, using '?.' instead will cause a null value of the expected type to be returned instead, preventing the runtime error occuring. Note however that this involves some overhead as it means the object must be checked before it is accessed. The 'Elvis operator' is a binary operator that returns its left hand argument if it is non-null, otherwise it returns its right hand argument. It is similar to 'X<>Null ? X Else Null' except that 'X' is only evaluted once.","title":"Operator precedence"},{"location":"docs/lang/pointer/","text":"Pointers # Introduction # Pointers are special variables containing a memory address. In Wonkey pointers are mainly used with external C/C++ code. Try not to use pointers unless absolutely necessary. It can lead to bugs if the pointed address is not kept \"alive\". Pointers to globals are safe, for example. You must have access to the memory you're trying to reach or you'll have a (fatal) memory access violation. A pointer should not point to a class instance. To get a pointer to your class object, you'll have to cast it to Void Ptr . See example below. Pointer declaration: Ptr # Use the Ptr keyword to declare a pointer. Local myPtr : Int Ptr Local anotherPtr : Void Ptr Pointer referencing: VarPtr # Use the VarPtr operator to reference a pointer Local i : Int = 1 Local myPtr : Int Ptr myPtr = VarPtr i The myPtr pointer now points to the variable i . Dereferencing with [] # You can access the pointed value(s) with the [] index operator Local i : Int = 1 Local myPtr : Int Ptr myPtr = VarPtr i Print myPtr [ 0 ] Will print 1, the value of i . Warning You can use pointer arithmetics with the index operator [] but you have to be sure you have access to that part of the memory or you'll get a memory access violation! Dereferencing with -> # You can access a struct's fields, methods,.. with the -> operator. It is equivalent to [0]. . Note that creating a pointer to class is prohibited. Struct Str Field i : Int = 1 End Function Main () Local s : = New Str Local strPtr : Str Ptr strPtr = VarPtr s Print strPtr -> i End will show the value of the struct's field i Casting # You can Cast a pointer and do some explicit conversions with the Cast operator. Cast<Type>(address) An example with a conversion from Class(reference) to Void Ptr to Class: Local foo : = New myFooClass () Local myVoidPtr : Void Ptr myVoidPtr = Cast < Void Ptr > ( foo ) Local foo2 : myFooClass foo2 = Cast < myFooClass > ( myVoidPtr ) \"foo\" and \"foo2\" will have the same address(reference). Note that casting to Void Ptr is commonly used when dealing with external native code.","title":"Pointers"},{"location":"docs/lang/pointer/#pointers","text":"","title":"Pointers"},{"location":"docs/lang/pointer/#introduction","text":"Pointers are special variables containing a memory address. In Wonkey pointers are mainly used with external C/C++ code. Try not to use pointers unless absolutely necessary. It can lead to bugs if the pointed address is not kept \"alive\". Pointers to globals are safe, for example. You must have access to the memory you're trying to reach or you'll have a (fatal) memory access violation. A pointer should not point to a class instance. To get a pointer to your class object, you'll have to cast it to Void Ptr . See example below.","title":"Introduction"},{"location":"docs/lang/pointer/#pointer_declaration_ptr","text":"Use the Ptr keyword to declare a pointer. Local myPtr : Int Ptr Local anotherPtr : Void Ptr","title":"Pointer declaration: Ptr"},{"location":"docs/lang/pointer/#pointer_referencing_varptr","text":"Use the VarPtr operator to reference a pointer Local i : Int = 1 Local myPtr : Int Ptr myPtr = VarPtr i The myPtr pointer now points to the variable i .","title":"Pointer referencing: VarPtr"},{"location":"docs/lang/pointer/#dereferencing_with","text":"You can access the pointed value(s) with the [] index operator Local i : Int = 1 Local myPtr : Int Ptr myPtr = VarPtr i Print myPtr [ 0 ] Will print 1, the value of i . Warning You can use pointer arithmetics with the index operator [] but you have to be sure you have access to that part of the memory or you'll get a memory access violation!","title":"Dereferencing with []"},{"location":"docs/lang/pointer/#dereferencing_with_-","text":"You can access a struct's fields, methods,.. with the -> operator. It is equivalent to [0]. . Note that creating a pointer to class is prohibited. Struct Str Field i : Int = 1 End Function Main () Local s : = New Str Local strPtr : Str Ptr strPtr = VarPtr s Print strPtr -> i End will show the value of the struct's field i","title":"Dereferencing with -&gt;"},{"location":"docs/lang/pointer/#casting","text":"You can Cast a pointer and do some explicit conversions with the Cast operator. Cast<Type>(address) An example with a conversion from Class(reference) to Void Ptr to Class: Local foo : = New myFooClass () Local myVoidPtr : Void Ptr myVoidPtr = Cast < Void Ptr > ( foo ) Local foo2 : myFooClass foo2 = Cast < myFooClass > ( myVoidPtr ) \"foo\" and \"foo2\" will have the same address(reference). Note that casting to Void Ptr is commonly used when dealing with external native code.","title":"Casting"},{"location":"docs/lang/preprocessor/","text":"The Preprocessor # Introduction # Wonkey includes a simple preprocessor that allows you to conditionally compile code depending on a number of build setttings. The preprocessor supports the following statements: #Import, #If, #Else, #ElseIf, #EndIf, #Rem, #End. Preprocessor statements must begin on a new line. #Import # For #Import see the topic Imports . #Rem .. #End # For block comments using #Rem and #End see the topic Comments . #If .. #Else .. #ElseIf .. #EndIf # Preprocessor expressions may only use the 'And', 'Or' and comparison operators. The following symbols may be used in preprocessor expressions: Symbol Type Meaning __TARGET__ String The current build target. One of: \"windows\", \"macos\", \"linux\", \"raspberry\", \"android\", \"ios\", \"emscripten\" __CONFIG__ String The current build config. One of: \"release\", \"debug\" __DESKTOP_TARGET__ Bool True if the current build target is windows, macos or linux. __MOBILE_TARGET__ Bool True if the current build target is android or ios. __WEB_TARGET__ Bool True if the current build target is emscripten. __DEBUG__ Bool True if the current build config is debug. __RELEASE__ Bool True if the current build config is release. For example, to include code in debug builds only, use something like: #If __DEBUG__ Print \"This code is only included in debug builds.\" #Endif To include code on desktop or mobile builds, use: #If __DESKTOP_TARGET__ Or __MOBILE_TARGET__ Print \"This code is only include in desktop and mobile builds.\" #Endif","title":"The Preprocessor"},{"location":"docs/lang/preprocessor/#the_preprocessor","text":"","title":"The Preprocessor"},{"location":"docs/lang/preprocessor/#introduction","text":"Wonkey includes a simple preprocessor that allows you to conditionally compile code depending on a number of build setttings. The preprocessor supports the following statements: #Import, #If, #Else, #ElseIf, #EndIf, #Rem, #End. Preprocessor statements must begin on a new line.","title":"Introduction"},{"location":"docs/lang/preprocessor/#import","text":"For #Import see the topic Imports .","title":"#Import"},{"location":"docs/lang/preprocessor/#rem_end","text":"For block comments using #Rem and #End see the topic Comments .","title":"#Rem .. #End"},{"location":"docs/lang/preprocessor/#if_else_elseif_endif","text":"Preprocessor expressions may only use the 'And', 'Or' and comparison operators. The following symbols may be used in preprocessor expressions: Symbol Type Meaning __TARGET__ String The current build target. One of: \"windows\", \"macos\", \"linux\", \"raspberry\", \"android\", \"ios\", \"emscripten\" __CONFIG__ String The current build config. One of: \"release\", \"debug\" __DESKTOP_TARGET__ Bool True if the current build target is windows, macos or linux. __MOBILE_TARGET__ Bool True if the current build target is android or ios. __WEB_TARGET__ Bool True if the current build target is emscripten. __DEBUG__ Bool True if the current build config is debug. __RELEASE__ Bool True if the current build config is release. For example, to include code in debug builds only, use something like: #If __DEBUG__ Print \"This code is only included in debug builds.\" #Endif To include code on desktop or mobile builds, use: #If __DESKTOP_TARGET__ Or __MOBILE_TARGET__ Print \"This code is only include in desktop and mobile builds.\" #Endif","title":"#If .. #Else .. #ElseIf .. #EndIf"},{"location":"docs/lang/property/","text":"Property # Introduction # To declare a read/write property: Property Identifier : Type () ... getter code ... Setter ( Identifier : Type ) ... setter code ... End To declare a read only property: Property Identifier : Type () ... getter code ... End To declare a write only property: Property ( Identifier : Type ) ... setter code ... End","title":"Properties"},{"location":"docs/lang/property/#property","text":"","title":"Property"},{"location":"docs/lang/property/#introduction","text":"To declare a read/write property: Property Identifier : Type () ... getter code ... Setter ( Identifier : Type ) ... setter code ... End To declare a read only property: Property Identifier : Type () ... getter code ... End To declare a write only property: Property ( Identifier : Type ) ... setter code ... End","title":"Introduction"},{"location":"docs/lang/reflection/","text":"Reflection # Introduction # To use reflection in your code, you first need to import the reflection module. #Import \"<reflection>\" Typeof and TypeInfo # The Typeof operator return a TypeInfo object, that contains various properties and methods for inspecting types at runtime. There are 2 ways to use Typeof: Local type : = Typeof ( expression ) Local type : = Typeof < type > The use of seperate () and <> delimeters is to prevent the parser getting confused by complex expressions. TypeInfo objects have a To:String operator (mainly for debugging) so can be printed directly: Print Typeof < Int > Print Typeof < Int Ptr > Local t : = 10 Print Typeof ( t ) Print Typeof ( \"yes\" ) Typeof returns the 'static' type of a class object. To get the actual instance type, use the Object.InstanceType property: Class C End Class D Extends C End Function Main () Local c : C = new D Print Typeof ( c ) ' Class default.C Print c . InstanceType ' Class default.D End You can retrieve the type of the value contained in a variant using the Variant.Type property: Local v : = Variant ( 10 ) ' creates a variant containing an int. Print v . Type ' prints 'Int' TypeInfo also includes functions for inspecting all user defined types: Function TypeInfo.GetType( name:String ) Returns the TypeInfo for a named type. A named type is a namespace or class declared by your app - it does not include primitive types, pointer types, array types etc. Class names must be prefixed by the namespace they are declared in. To get an array of ALL named types: Function TypeInfo.GetTypes:TypeInfo[]() DeclInfo objects # TypeInfo objects for namespaces and classes also contain a set of DeclInfo objects. A DeclInfo represents the member declarations inside of a namespace or class. Currently, only global, field, method and function members are supported. DeclInfo objects also have a To:String operator to help with debugging. You can inspect the member decls of a type using the TypeInfo.GetDecls method: Namespace mynamespace Global test : Int Function Main () Local type : = TypeInfo . GetType ( \"mynamespace.MyClass\" ) For Local decl : = Eachin type . GetDecls () Print decl Next End You can retrieve a single unique member using TypeInfo.GetDecl: Local type : = TypeInfo . GetType ( \"mynamespace.MyClass\" ) Local ctor : = type . GetDecl ( \"New\" ) There may be several decls with the same name due to method and function overloading, in which case the simple GetDecl above will fail and return null. In this case, you either need to inspect each decl individually to find the one you want, or you can pass an additional TypeInfo parameter to GetDecl: Local type : = TypeInfo . GetType ( \"MyNamespace.MyClass\" ) Local ctor : = type . GetDecl ( \"New\" , Typeof < Void () > ) This will return the default constructor for MyClass, assuming there is one. Getting and setting variables # Member decls that represent variables (ie: fields and globals) can be read and written using the DeclInfo.Get and Decl.Info.Set methods: Namespace mynamespace Global MyGlobal : Int Function Main () Local vdecl : = TypeInfo . GetType ( \"mynamespace\" ). GetDecl ( \"MyGlobal\" ) vdecl . Set ( Null , 10 ) Print MyGlobal Print Cast < Int > ( vdecl . Get ( Null ) ) End The first parameter of Set and Get is an object instance, which must be non-null for getting and setting fields. The second parameter of Set is a variant, and is the value to assign to the variable. The type of the value contained in the variant must match the variable type exactly, or a runtime error will occur. Note that since any value can be cast to a variant, we can just provide the literal value '10' for Set and it will be implictly converted to a variant for us. On the other hand, we must explicitly cast the result of Get() from a variant back to the type of value we want. Invoking methods and functions # To invoke methods and functions, use the DeclInfo.Invoke method: namespace mynamespace Function Test ( msg : String ) Print \"Test! msg=\" + msg End Function Main () Local fdecl : = TypeInfo . GetType ( \"mynamespace\" ). GetDecl ( \"Test\" ) fdecl . Invoke ( Null , New Variant []( \"Hello Test!\" ) ) End The first parameter of Invoke is an object instance, which must be non-null for invoking methods. The second parameter of Invoke is an array of variants that represents the parameters for the call. The types of these parameters must match the parameter types of the actual method or function exactly, or a runtime error will occur. Limitations # Currently, typeinfo is only generated for non-generic, non-extension, non-extern 100% pure Wonkey globals, fields, function, methods, classes and namespaces. You can still use other types (structs etc) with variants etc, but you wont be able to inspect their members. Typeinfo may be stripped out by the linker. I've added a little hack to mojo to keep module typeinfo 'alive', but there is still work to do here. If you find the linker stripping out typeinfo, you can prevent it doing so for now by adding a 'Typeof' to Main() referencing the type you want to keep alive. Or, you can set WX_WHOLE_ARCHIVE in bin/env_blah.txt to '1' to force the linker to include ALL code, but this will of course produce larger executables.","title":"Reflection"},{"location":"docs/lang/reflection/#reflection","text":"","title":"Reflection"},{"location":"docs/lang/reflection/#introduction","text":"To use reflection in your code, you first need to import the reflection module. #Import \"<reflection>\"","title":"Introduction"},{"location":"docs/lang/reflection/#typeof_and_typeinfo","text":"The Typeof operator return a TypeInfo object, that contains various properties and methods for inspecting types at runtime. There are 2 ways to use Typeof: Local type : = Typeof ( expression ) Local type : = Typeof < type > The use of seperate () and <> delimeters is to prevent the parser getting confused by complex expressions. TypeInfo objects have a To:String operator (mainly for debugging) so can be printed directly: Print Typeof < Int > Print Typeof < Int Ptr > Local t : = 10 Print Typeof ( t ) Print Typeof ( \"yes\" ) Typeof returns the 'static' type of a class object. To get the actual instance type, use the Object.InstanceType property: Class C End Class D Extends C End Function Main () Local c : C = new D Print Typeof ( c ) ' Class default.C Print c . InstanceType ' Class default.D End You can retrieve the type of the value contained in a variant using the Variant.Type property: Local v : = Variant ( 10 ) ' creates a variant containing an int. Print v . Type ' prints 'Int' TypeInfo also includes functions for inspecting all user defined types: Function TypeInfo.GetType( name:String ) Returns the TypeInfo for a named type. A named type is a namespace or class declared by your app - it does not include primitive types, pointer types, array types etc. Class names must be prefixed by the namespace they are declared in. To get an array of ALL named types: Function TypeInfo.GetTypes:TypeInfo[]()","title":"Typeof and TypeInfo"},{"location":"docs/lang/reflection/#declinfo_objects","text":"TypeInfo objects for namespaces and classes also contain a set of DeclInfo objects. A DeclInfo represents the member declarations inside of a namespace or class. Currently, only global, field, method and function members are supported. DeclInfo objects also have a To:String operator to help with debugging. You can inspect the member decls of a type using the TypeInfo.GetDecls method: Namespace mynamespace Global test : Int Function Main () Local type : = TypeInfo . GetType ( \"mynamespace.MyClass\" ) For Local decl : = Eachin type . GetDecls () Print decl Next End You can retrieve a single unique member using TypeInfo.GetDecl: Local type : = TypeInfo . GetType ( \"mynamespace.MyClass\" ) Local ctor : = type . GetDecl ( \"New\" ) There may be several decls with the same name due to method and function overloading, in which case the simple GetDecl above will fail and return null. In this case, you either need to inspect each decl individually to find the one you want, or you can pass an additional TypeInfo parameter to GetDecl: Local type : = TypeInfo . GetType ( \"MyNamespace.MyClass\" ) Local ctor : = type . GetDecl ( \"New\" , Typeof < Void () > ) This will return the default constructor for MyClass, assuming there is one.","title":"DeclInfo objects"},{"location":"docs/lang/reflection/#getting_and_setting_variables","text":"Member decls that represent variables (ie: fields and globals) can be read and written using the DeclInfo.Get and Decl.Info.Set methods: Namespace mynamespace Global MyGlobal : Int Function Main () Local vdecl : = TypeInfo . GetType ( \"mynamespace\" ). GetDecl ( \"MyGlobal\" ) vdecl . Set ( Null , 10 ) Print MyGlobal Print Cast < Int > ( vdecl . Get ( Null ) ) End The first parameter of Set and Get is an object instance, which must be non-null for getting and setting fields. The second parameter of Set is a variant, and is the value to assign to the variable. The type of the value contained in the variant must match the variable type exactly, or a runtime error will occur. Note that since any value can be cast to a variant, we can just provide the literal value '10' for Set and it will be implictly converted to a variant for us. On the other hand, we must explicitly cast the result of Get() from a variant back to the type of value we want.","title":"Getting and setting variables"},{"location":"docs/lang/reflection/#invoking_methods_and_functions","text":"To invoke methods and functions, use the DeclInfo.Invoke method: namespace mynamespace Function Test ( msg : String ) Print \"Test! msg=\" + msg End Function Main () Local fdecl : = TypeInfo . GetType ( \"mynamespace\" ). GetDecl ( \"Test\" ) fdecl . Invoke ( Null , New Variant []( \"Hello Test!\" ) ) End The first parameter of Invoke is an object instance, which must be non-null for invoking methods. The second parameter of Invoke is an array of variants that represents the parameters for the call. The types of these parameters must match the parameter types of the actual method or function exactly, or a runtime error will occur.","title":"Invoking methods and functions"},{"location":"docs/lang/reflection/#limitations","text":"Currently, typeinfo is only generated for non-generic, non-extension, non-extern 100% pure Wonkey globals, fields, function, methods, classes and namespaces. You can still use other types (structs etc) with variants etc, but you wont be able to inspect their members. Typeinfo may be stripped out by the linker. I've added a little hack to mojo to keep module typeinfo 'alive', but there is still work to do here. If you find the linker stripping out typeinfo, you can prevent it doing so for now by adding a 'Typeof' to Main() referencing the type you want to keep alive. Or, you can set WX_WHOLE_ARCHIVE in bin/env_blah.txt to '1' to force the linker to include ALL code, but this will of course produce larger executables.","title":"Limitations"},{"location":"docs/lang/string/","text":"String # Introduction # A String is an immutable sequence of 16 bit characters that is usually used to represent text. String literals are sequences of characters enclosed in \" (quotation marks / doublequote). String literals may also include escape sequences, special sequences of characters used to represent unprintable characters. Escape characters # You can use the following escape sequences in string literals: Escape sequence Character code ~q 34 (quotation mark \") ~n 10 (newline) ~r 13 (return) ~t 9 (tab) ~z 0 (null) ~~ 126 (tilde ~) For example, to include literal quotation marks in a string: Local test : = \" ~q Hello World ~q \" Strings can also be declared across multiple lines: Const multiLine : = \" Multi Line String \" In this case, each newline inside the quote marks is simply included in the string, so the above example string actually contains 2 'hidden' newlines. String variables are declared using the type name String , for example: Local test : String = \"Hello World\" You can index a string using the [] operator: Local str : = \"Hello World\" For Local i : = 0 Until str . Length Print str [ i ] Next Indexing a string will return the character code at a given string index as an int. You can iterate through the characters in a string using Eachin : For Local chr : = Eachin \"Hello World\" Print chr Next","title":"Strings"},{"location":"docs/lang/string/#string","text":"","title":"String"},{"location":"docs/lang/string/#introduction","text":"A String is an immutable sequence of 16 bit characters that is usually used to represent text. String literals are sequences of characters enclosed in \" (quotation marks / doublequote). String literals may also include escape sequences, special sequences of characters used to represent unprintable characters.","title":"Introduction"},{"location":"docs/lang/string/#escape_characters","text":"You can use the following escape sequences in string literals: Escape sequence Character code ~q 34 (quotation mark \") ~n 10 (newline) ~r 13 (return) ~t 9 (tab) ~z 0 (null) ~~ 126 (tilde ~) For example, to include literal quotation marks in a string: Local test : = \" ~q Hello World ~q \" Strings can also be declared across multiple lines: Const multiLine : = \" Multi Line String \" In this case, each newline inside the quote marks is simply included in the string, so the above example string actually contains 2 'hidden' newlines. String variables are declared using the type name String , for example: Local test : String = \"Hello World\" You can index a string using the [] operator: Local str : = \"Hello World\" For Local i : = 0 Until str . Length Print str [ i ] Next Indexing a string will return the character code at a given string index as an int. You can iterate through the characters in a string using Eachin : For Local chr : = Eachin \"Hello World\" Print chr Next","title":"Escape characters"},{"location":"docs/lang/struct/","text":"Struct # Introduction # Structs are similar classes, but differ in several important ways: A struct is a 'value type', whereas a class is a 'reference type'. This means that when you assign a struct to a variable, pass a struct to a function or return a struct from a function, the entire struct is copied in the process. Stucts are statically typed, whereas classes are dynamically typed. Struct methods cannot be virtual. A struct cannot extend anything. To declare a struct: Struct Identifier [ < GenericTypeIdents > ] ... Struct members ... End A struct can contain const, global, field, method and function declaratins, as well as other user defined types.","title":"Structs"},{"location":"docs/lang/struct/#struct","text":"","title":"Struct"},{"location":"docs/lang/struct/#introduction","text":"Structs are similar classes, but differ in several important ways: A struct is a 'value type', whereas a class is a 'reference type'. This means that when you assign a struct to a variable, pass a struct to a function or return a struct from a function, the entire struct is copied in the process. Stucts are statically typed, whereas classes are dynamically typed. Struct methods cannot be virtual. A struct cannot extend anything. To declare a struct: Struct Identifier [ < GenericTypeIdents > ] ... Struct members ... End A struct can contain const, global, field, method and function declaratins, as well as other user defined types.","title":"Introduction"},{"location":"docs/lang/type-balancing/","text":"Type balancing # Introduction # When evaluating an operator's operands, it is sometimes necessary to adjust the type of one or both operands. When evaluating the operands of arithemetic or comparison operators, the following rules are used: If either operator is String, the other is converted to String. Else If either operand is Double, the other is converted to Double. Else if either operand is Float, the other is converted to Float. Else if either operand is ULong, the other is converted to ULong. Else if either operand is Long, the other is converted to Long. Else if either operand is unsigned, both are converted to UInt. Else both operands are converted to Int. When evaluating the operands of the & , | and ^ integer operators, both operands must be integral types and are converted as follows: If either operand is ULong, the other is converted to ULong. Else if either operand is Long, the other is converted to Long. Else if either operand is unsigned, both are converted to UInt. Else both operands are converted to Int. When evaluating the operand of the Shl and Shr integer operators, the left-hand-side must be an integral type, while the right-hand-side 'shift amount' operand is converted to Int.","title":"Type balancing"},{"location":"docs/lang/type-balancing/#type_balancing","text":"","title":"Type balancing"},{"location":"docs/lang/type-balancing/#introduction","text":"When evaluating an operator's operands, it is sometimes necessary to adjust the type of one or both operands. When evaluating the operands of arithemetic or comparison operators, the following rules are used: If either operator is String, the other is converted to String. Else If either operand is Double, the other is converted to Double. Else if either operand is Float, the other is converted to Float. Else if either operand is ULong, the other is converted to ULong. Else if either operand is Long, the other is converted to Long. Else if either operand is unsigned, both are converted to UInt. Else both operands are converted to Int. When evaluating the operands of the & , | and ^ integer operators, both operands must be integral types and are converted as follows: If either operand is ULong, the other is converted to ULong. Else if either operand is Long, the other is converted to Long. Else if either operand is unsigned, both are converted to UInt. Else both operands are converted to Int. When evaluating the operand of the Shl and Shr integer operators, the left-hand-side must be an integral type, while the right-hand-side 'shift amount' operand is converted to Int.","title":"Introduction"},{"location":"docs/lang/variables/","text":"Variables # Local variables # Local variables live on the stack. To declare a local variable: Local identifier : Type [ = Expression ] ...or... Local identifier := Expression Global variables # Global variables live in global memory and exist for the lifetime of the application. To declare a global variable: Global Identifier : Type [ = Expression ] ...or... Global Identifier := Expression Consts # Consts are stored in the same way as globals, but cannot be modified after they are initialized. To declare a const: Const Identifier : Type = Expression ...or... Const Identifier := Expression Examples # Global counter : Int Const PI : Double = 3.5 Function Main () Local x : Int = 10 , y : Int = 20 Print counter IncCounter () Print counter Print x Print y End Function IncCounter () counter += 1 End","title":"Variables"},{"location":"docs/lang/variables/#variables","text":"","title":"Variables"},{"location":"docs/lang/variables/#local_variables","text":"Local variables live on the stack. To declare a local variable: Local identifier : Type [ = Expression ] ...or... Local identifier := Expression","title":"Local variables"},{"location":"docs/lang/variables/#global_variables","text":"Global variables live in global memory and exist for the lifetime of the application. To declare a global variable: Global Identifier : Type [ = Expression ] ...or... Global Identifier := Expression","title":"Global variables"},{"location":"docs/lang/variables/#consts","text":"Consts are stored in the same way as globals, but cannot be modified after they are initialized. To declare a const: Const Identifier : Type = Expression ...or... Const Identifier := Expression","title":"Consts"},{"location":"docs/lang/variables/#examples","text":"Global counter : Int Const PI : Double = 3.5 Function Main () Local x : Int = 10 , y : Int = 20 Print counter IncCounter () Print counter Print x Print y End Function IncCounter () counter += 1 End","title":"Examples"},{"location":"docs/lang/variant/","text":"Variant # Introduction # A Variant is a special value that can be used to 'box' values of any other type. The easiest way to create a variant is to cast a value to Variant (much like casting an Int to String etc), eg: Local v := Variant( 10 ) An uninitialized variant will contain a 'null' value (of type Void) until you assign something to it: Local v : Variant v = 10 ' variant now contains an int 10. v = \"hello\" ' variant now contains a string \"hello\". A variant is true if it is initialized (even if it contains a bool 'false' value) and false if it is uninitialized. There is currently no way to uninitialize a variant, so once a variant is initialized it will always be 'true'. Any type of value can be implicitly converted to a variant, so you can easily pass anything to a function with variant parameters: Function Test ( v : Variant ) End Function Main () Test ( 1 ) Test ( \"Hello\" ) Test ( New Int [] ) Test ( Main ) End To retrieve the value contained in a variant, you must explicitly cast the variant to the desired type: Local v : = Variant ( 100 ) Print Cast < Int > ( v ) Note that the cast must specify the exact type of the value already contained in the variant, or a runtime error will occur: Local v : = Variant ( 10 ) Print Cast < String > ( v ) ' Runtime error! Variant contains an Int not a String! The one exception to this is if the variant contains a instance of an object, in which case you can cast the variant to any valid base class of the object's actual type.","title":"Variants"},{"location":"docs/lang/variant/#variant","text":"","title":"Variant"},{"location":"docs/lang/variant/#introduction","text":"A Variant is a special value that can be used to 'box' values of any other type. The easiest way to create a variant is to cast a value to Variant (much like casting an Int to String etc), eg: Local v := Variant( 10 ) An uninitialized variant will contain a 'null' value (of type Void) until you assign something to it: Local v : Variant v = 10 ' variant now contains an int 10. v = \"hello\" ' variant now contains a string \"hello\". A variant is true if it is initialized (even if it contains a bool 'false' value) and false if it is uninitialized. There is currently no way to uninitialize a variant, so once a variant is initialized it will always be 'true'. Any type of value can be implicitly converted to a variant, so you can easily pass anything to a function with variant parameters: Function Test ( v : Variant ) End Function Main () Test ( 1 ) Test ( \"Hello\" ) Test ( New Int [] ) Test ( Main ) End To retrieve the value contained in a variant, you must explicitly cast the variant to the desired type: Local v : = Variant ( 100 ) Print Cast < Int > ( v ) Note that the cast must specify the exact type of the value already contained in the variant, or a runtime error will occur: Local v : = Variant ( 10 ) Print Cast < String > ( v ) ' Runtime error! Variant contains an Int not a String! The one exception to this is if the variant contains a instance of an object, in which case you can cast the variant to any valid base class of the object's actual type.","title":"Introduction"},{"location":"docs/lang/weak-references/","text":"Weak References # Introduction # A weak reference is a special kind of reference to an object that does not prevent that object from being garbage collected. Normally, storing a reference to an object in a variable will prevent that object from ever being garbage collected as long as the variable itself remains alive. However, weak references allow you store a reference will still allowing the object to be garbage collected. The object a weak reference refers to is called the 'target' object. To create a weak reference, you must create a WeakRef object with the target object. Then, when you want to obtain the target object from a weak reference, you should use the Target property. Here is a simple example: Local weakref : WeakRef = New WeakRef ( someObject ) ' Some time later... Local target : Object = weakref . Target ' May return Null if someObject has been garbage collected. The Target property will return the object the weak reference was created with unless the object has been garbage collected, in which case it will return null. A weak reference itself is just an object so will also be garbage collected when it is itself no longer referenced by any variables. Weak references are often used for creating 'cache' systems.","title":"Weak references"},{"location":"docs/lang/weak-references/#weak_references","text":"","title":"Weak References"},{"location":"docs/lang/weak-references/#introduction","text":"A weak reference is a special kind of reference to an object that does not prevent that object from being garbage collected. Normally, storing a reference to an object in a variable will prevent that object from ever being garbage collected as long as the variable itself remains alive. However, weak references allow you store a reference will still allowing the object to be garbage collected. The object a weak reference refers to is called the 'target' object. To create a weak reference, you must create a WeakRef object with the target object. Then, when you want to obtain the target object from a weak reference, you should use the Target property. Here is a simple example: Local weakref : WeakRef = New WeakRef ( someObject ) ' Some time later... Local target : Object = weakref . Target ' May return Null if someObject has been garbage collected. The Target property will return the object the weak reference was created with unless the object has been garbage collected, in which case it will return null. A weak reference itself is just an object so will also be garbage collected when it is itself no longer referenced by any variables. Weak references are often used for creating 'cache' systems.","title":"Introduction"},{"location":"docs/modules/","text":"Wonkey modules reference #","title":"Index"},{"location":"docs/modules/#wonkey_modules_reference","text":"","title":"Wonkey modules reference"}]}